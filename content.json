{"pages":[{"title":"我没有啥想说的，就看你想说啥~","permalink":"https://yimogit.github.io/about/index.html","text":"我？一个程序猿。你？return a == b ? a : b;"},{"title":"我的收藏夹","permalink":"https://yimogit.github.io/collections/index.html","text":"个人相关 Github: https://github.com/yimogit/ Coding：https://coding.net/u/yimocoding/ 专属工具：https://tools.yimo.link/ 私人定制：https://app.yimo.link/ 系统软件：http://pan.baidu.com/s/1qYLi2SG a2iu 个人书签: 2017_5_28 二次元 哔哩哔哩：https://www.bilibili.com/ 嘀哩嘀哩：http://www.dilidili.wang/ 腾讯动漫：http://ac.qq.com/ 大神博客 阮一峰：http://www.ruanyifeng.com/blog/ 老D博客：https://laod.cn/ 技术手册 Nginx中文文档 http://www.nginx.cn/doc/index.html Linux命令大全 http://www.nginx.cn/docs/command.html 常用网站 博客园：https://www.cnblogs.com/ 掘金：https://juejin.im/ 在线工具：http://tool.oschina.net/"},{"title":"每日一图","permalink":"https://yimogit.github.io/daypics/index.html","text":""},{"title":"闲言碎语","permalink":"https://yimogit.github.io/gossip/index.html","text":"hexo博客搭建完成coding地址：https://coding.net/u/yimocoding/p/yimocoding/gitgithub地址：https://github.com/yimogit/yimogit.github.io/tree/hexothemes 添加时间轴 添加功能：时间轴只需要在md文件里面加上一个timeline标签，然后一个标题+内容就可以随心的创造时间轴的页面了hexo功能：如果要在md里写代码只需要加入raw标签即可 content隐藏功能：文章中如果把date设置成1900-01-01就可以隐藏页面的时间不显示 添加travis-ci集成 travis-ci https://travis-ci.org参考文章：https://juejin.im/post/596e39916fb9a06baf2ed273参考文章：http://blog.csdn.net/woblog/article/details/51319364"},{"title":"你一定是产生了幻觉","permalink":"https://yimogit.github.io/readpics/index.html","text":"2017-05-24 2017-07-04"},{"title":"随便记记罢了","permalink":"https://yimogit.github.io/record/index.html","text":"2017-05-20 13:14 hexo博客搭建完成coding地址：https://coding.net/u/yimocoding/p/yimocoding/gitgithub地址：https://github.com/yimogit/yimogit.github.io/tree/hexothemes线上地址：http://www.yimo.link/ 2017-05-22 20:11 添加时间轴 添加功能：时间轴只需要在md文件里面加上一个timeline标签，然后一个标题+内容就可以随心的创造时间轴的页面了hexo功能：如果要在md里写代码只需要加入raw标签即可 content隐藏功能：文章中如果把date设置成1900-01-01就可以隐藏页面的时间不显示 2017-05-22 20:11 整体优化了一波修改了超级多样式，字体文件给去掉了，百度统计独立key，畅言js调整到了最后加载 2017-05-25 00:11 传送门+每日一图 传送门就是一个收藏夹~每日一图的图片后面敬请期待~ 2017-05-28 13:01 添加收藏文件夹 放一些收藏 个人书签 google guitar添加个人书签及生成ssh公钥 ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 保存在 C:\\Users\\用户名\\.ssh 2017-05-29 15:11 添加技术手册 Nginx中文文档 http://www.nginx.cn/doc/index.html Linux命令大全 http://www.nginx.cn/docs/command.html 2017-05-29 20:38 稍微优化整理了一下 顶部进度条显示文章详情页上一篇下一篇功能优化css,js引用，添加cdn配置。 2017-05-30 18:38 胡乱的折腾着过了三天 metools添加HTML转markdown，识别二维码功能听梦网~一个不知道干啥的网站。 2017-06-04 02:08 清理缓存脚本完成 重启服务器iis，根据配置清理redis缓存，我想，以后会有再用到的时候吧。半天的时间写脚本，一晚上的时间写文章，我想，应该是值得的吧。 2017-07-04 09:55 完成DB数据导出工具 一个根据数据库链接字符串，sql语句 即可将结果集导出到Excel的工具 分享，支持sqlserver,mysql。下载源码顺便更新了一波博客 2017-07-08 18:20 完成图片下载工具 一个根据页面地址即可提取图片到本的工具下载使用 2017-07-10 00:25 .net core踩坑demo 用新技术实现新的想法，一举多得。可用来在线管理hexo博客，及git图床功能~"},{"title":"易墨的书签","permalink":"https://yimogit.github.io/collections/webpage/bookmarks_2017_5_28.html","text":"Bookmarks Bookmarks 书签栏 工具 搜Md5 - So Md5 Cracker System 在线JSON校验格式化工具（Be JSON） HTML 教程 w3cschool菜鸟教程 颜色搭配 免费代理ip_服务器http代理_最新ip代理_免费ip提取网站_国内外代理_66软件代理提取 在线生成sitemap JS Bin - Collaborative JavaScript Debugging PROXY999 百度地图 - 上海市轨道交通图 在线二维码生成器 在线二维码解码器 二维码安全检测工具 Chrome插件(谷歌浏览器插件) - 提供Chrome商店中优秀的Chrome插件推荐与下载服务 在线模拟发送HTTP请求 在线工具 —— 开源中国社区 快搜 — 搜索快人一步 - 百度 JSONLint - The JSON Validator. 艺术字体在线生成器 艺术字转换器 【天眼查】专业的企业工商信息查询!专业的发现人与企业关系的平台|企业信用查询|工商局企业信息查询 TinyPNG – Compress PNG images while preserving transparency 装逼在线生成器 在线抠图工具-图片去背景色,在线抠图网站 ps在线版 Photoshop在线精简版 xiaopiu-在线APP原型设计 iH5最专业的H5制作工具 代理IP提取 iOS启动图在线制作 酷传监控 - 专业的app数据监控平台 | 安卓 站长工具 - 站长之家 网站 娱乐 卡盟卡立购 麦客 - 简单好用的表单和联系人管理工具 趣味互动游戏：请画一个小人 动态图片基地_搞笑动态图片、gif图片、QQ图片原创收集基地-Asqql.coM 百度贴吧 找资料 网盘搜索，盘搜一下-国内优秀的百度网盘搜索引擎 OnionLink. We link you up with the onions. 腾讯大师兄 - 移动开发者工具镜像站点 有必要-也许正是你要找的！ 免翻墙Glgoo 搜索 主机 万网免费主机-虚拟主机-虚拟空间-万网（www.net.cn） 腾讯云 - 值得信赖 云+校园计划 - 腾讯云，值得信赖 峨眉主机供应中心-专业虚拟主机域名注册服务商!稳定、安全、高速的虚拟主机！域名注册虚拟主机租用 香港云 - 会员中心 免费空间 free.3v.do 提供100M永久免费ASP空间 景安网络-河南最大的民营数据中心！提供服务器租用、服务器托管、快云服务器、快云VPS、虚拟主机、免费SSL证书等 小米云-小米互联-云服务器,分销主机,小鸟云代理,wordpress主机,独立ip虚拟主机,秒赞主机 API接口 微信 【微信支付】普通商户接入文档 【微信H5支付】开发者文档 微信JS-SDK Demo 微信支付开发(7) H5支付 - 方倍工作室 - 博客园 微信公众平台 腾讯开放平台 OPEN.QQ.COM Bootstrap中文网开源项目免费 CDN 服务 野狗 - 控制面板 API数据接口_免费数据调用接口-聚合数据 博客收藏 代潇瑞博客-专注于PHP学习,PHP源码分享 贾鹏辉的技术博客|CrazyCodeBoy|JiaPenghui|fengyuzhegnfan|Cboy|Devio|codingio|专注移动技术开发(Android&amp;IOS)、React Native开发、React Native教程、React Native博客 Aissues-一个把碎片化知识系统化的网站,一个把书读薄的网站 Haorooms博客-前端博客-前端技术，记录web前端开发的技术博客 江清清的技术专栏|专注移动技术开发(Android/IOS)、React Native源码分析、React Native教程、React Native博客 Nosafe-非安全| 关注网络安全 Tags - 贾鹏辉的技术博客|CrazyCodeBoy|JiaPenghui|fengyuzhegnfan|Cboy|Devio|codingio|专注移动技术开发(Android&amp;IOS)、React Native开发、React Native教程、React Native博客 老D - 关注谷歌服务，分享互联网精神！ 编程随想的博客 杨青青博客 - 一个站在web前端设计之路的女技术员个人博客网站 将图片按9宫格等分的简单批处理脚本 – WEB骇客 阮一峰的网络日志 找工作 面试题 .net面试问答（大汇总） - 曾祥展 - 博客园 【汇总】SQL CODE --- 经典·精彩 - 曾祥展 - 博客园 拉勾网-最专业的互联网招聘平台 【官网】Boss直聘-互联网招聘神器！官方IP:直直 上海招聘网 智联招聘人才网 前程无忧 软件 火绒安全软件3.0-专注、纯粹，才能更安全 12306Bypass - 分流抢票 Green唯一官网 Greenvpn_Green加速器 green vpn下载 官网 文档 快速上手 - iView Ant Design - 一个 UI 设计语言 vue.js 资料 Git ASP.NET Boilerplate · GitHub pdf.jsweb at master · mozillapdf.js · GitHub Git权威指南视频教程 - 爱酷学习网，免费高清视频教程在线观看 ABP ABPFrameWorkGroup ABP博客 AbpZeroTemplate ASP.NET Boilerplate ASP.NET Identity入门系列教程（一） 初识Identity - 可米小子 - 博客园 AbpZeroTemplate AutoMapper小结 - 呆河马 - 博客园 Entity Framework - 标签 - china_fucan - 博客园 VisualSVN Server 基于DDD的现代ASP.NET开发框架--ABP系列文章总目录（2015-6-3 2245更新） - 阳光铭睿 - 博客园 AbpZeroTemplate AngularJS Angular.js Services - 破狼 - 博客园 AngularJS-Learning/ZH-CN.md at master · jmcunningham/AngularJS-Learning · GitHub AngularJS权威教程 清晰PDF版_Linux下载_Linux公社-Linux系统门户网站 AngularJS的学习 $on、$emit和$broadcast的使用 - 编程大巴 - 次元立方网 - 电脑知识与技术互动交流平台 AngularJs遇到的小坑与技巧 - Coolicer - 博客园 Angular范例程序 angularjs中factory,service,provider 自定义服务的不同-js教程-网页制作-壹聚教程网 《AngularJS》5个实例详解Directive（指令）机制 - 天上的神明与星辰，人间的艺术和真纯，我们所敬畏和热爱的，莫过于此。 - ITeye技术网站 对AngularJS进行性能调优的7个建议-CSDN.NET AngularJS提交表单的方式 - 技术文摘 - LUPA开源社区 angular-file-upload首页、文档和下载 - AngularJS 文件上传工具 - 开源中国社区 AngularJS路由和模板 粉丝日志 Angularjs第三方模块angular-route和angular-ui-router的区别、差异、不同 - Javascript - 郑州网建 NET 文档 NopCommerce中文数据字典-零度 Asp.net Core .NET Core 1.0 RC2 历险之旅 - 江大渔 - 博客园 使用VS Code开发调试ASP.NET Core 1.0 - LineZero - 博客园 dotnet/cli: This repo contains the .NET Core command-line (CLI) tools, used for building .NET Core apps and libraries through your development flow (compiling, NuGet package management, running, testing, ...). DTcms DTcms插件网-专业的ASP.NET插件制作、模板设计、功能定制开发平台 .NET Core 使用VS Code开发调试ASP.NET Core 1.0 - LineZero - 博客园 Nopcommerce nopcommerce中文网 | nopcommerce是国外asp.net领域一个高质量的b2c开源项目，基于EntityFramework和MVC开发，交流QQ群：75272942（2000人超级群） 蓝狐软件工作室-成都高端网站建设_成都APP开发_成都系统开发定制_成都高端企业官网建设-企业高端信息化服务优秀品牌 并发 当DiscuzNT遇上了Loadrunner(上) - 代震军 - 博客园 asp.net解决高并发的方案. - 75077027 - 博客园 ab网站压力测试命令的参数、输出结果的中文注解 - 闽南土著 - 博客频道 - CSDN.NET Asp.Net MVC中使用ACE模板之Jqgrid(3) - 51CTO.COM C# Winform项目中多线程环境下, 如何跨线程对Window窗体控件进行安全访问？ - 其实我不是代码教父,我只是猪头三 - 博客频道 - CSDN.NET js 设置header，实现跨域访问 - 追求卓越,做到专业 - 博客频道 - CSDN.NET Spring.net依赖注入及环境配置 - XueM - 博客园 简单、轻量、功能非常强大的C#/ASP.NET定时调度任务执行管理组件–FluentScheduler之实例篇 – 图享网 C#设计模式总结 - Learning hard - 博客园 Asp.Net MVC及Web API框架配置会碰到的几个问题及解决方案 MVC上传图片 - shizhi57 - 博客园 WebApi 登录身份验证 - yo548720570的专栏 - 博客频道 - CSDN.NET 面向对象三大基本特性,五大基本原则 - Leo Chin - 博客园 Web用户的身份验证及WebApi权限验证流程的设计和实现 - 上步七星 - 博客频道 - CSDN.NET 等到花儿也谢了的await - dudu - 博客园 关于C#操作INI文件的总结 - Cheek G - 博客园 C# Excel导入、导出 - polk6 - 博客园 所有程序员都应该遵守的11条规则_知识库_博客园 那些年我们一起追过的缓存写法(一) - 蘑菇先生 - 博客园 PowerDesigner使用教程|使用方法 - 学习博客 - BlogJava C#基础系列——再也不用担心面试官问我“事件”了 - 懒得安分 - 博客园 使用Topshelf 5步创建Windows 服务 - 张善友 - 博客园 VS使用技巧 - 马语者 - 博客园 VS2010中的调试技巧_知识库_博客园 面试干货——年底干货大放送，你准备好了吗？ - 懒得安分 - 博客园 其他 Tencent AlloyTeam - 腾讯 Web 前端团队 Markdown 语法说明(简体中文版) 献给写作者的 Markdown 新手指南 - 简书 C#WebBrowser控件使用教程与技巧收集-苏飞收集-Api和接口-苏飞论坛 [苏飞开发助手]官方产品发布与源码下载-开发者工具网-苏飞论坛 使用Visual Studio 2013进行单元测试--初级篇-.Net-爱编程 基于Bootstrup 3可预览的HTML5文件上传插件 禁止windows10带来的三大隐患问题 - 攻防之路 - 博客园 省市区三级联动 win7升win10，初体验 - M_Kepler - 博客园 作为程序员之正则表达式 - M_Kepler - 博客园 aspx+mssql后台登陆注入拿webshell_風之恋long_新浪博客 前端 一款出色的JS日历控件bootstrap-datetimepicker_Js_网志博客 CSS3 ordered list styles - demo CSS Shake_实例展示_个人博客_余斗余斗 小青年博客 react React 入门实例教程 - 阮一峰的网络日志 Animate.css 无标题文档 中文api - Swiper中文网 vue.js webpack进阶构建项目(一) - 空智 - 博客园 国内有哪些公司在用Vue.js，有什么心得? - 前端开发 - 知乎 import - JavaScript | MDN view-source:www.17sucai.com/preview/25238/2015-07-02/PCASClass/demo.html Introducing Visual Studio Code Documentation - Metronic Admin Dashboard Template CSS3实现几个常用的网页小效果 - 郭锦荣 - 博客园 vue-router/docs/zh-cn at dev · vuejs/vue-router 动易 SiteFactory™ 提高培训课(第八期)-动易起航 SiteFactory系列教程汇总 [原创]用sitefactory仿网易盖楼评论 - 第1页 - SiteFactory交流区 - 动易论坛 - 广东动易软件股份有限公司 - Powered by bbsMax [原创]评论标签盖楼引用 - 第1页 - SiteFactory交流区 - 动易论坛 - 广东动易软件股份有限公司 - Powered by bbsMax 动易系统如何批量导入节点？ - DTOP - 动易设计团队博客 动易论坛 - 广东动易软件股份有限公司 - Powered by bbsMax 新增通用模板 页面区块管理——动易4.5版新特性 - 动易软件 安全 插件 FullCalendar日程管理插件 FullCalendar（日程管理控件） - 过天的专栏 - 博客频道 - CSDN.NET jquery.fullCalendar官方文档翻译(一款小巧好用的日程管理日历, 可集成Google Calendar) - goosman----swan goose - 博客频道 - CSDN.NET jqGrid My97日历插件 My97日期控件 演示 &amp; 文档 My97 DatePicker Demo &amp; Doc Jquery.DataTable jquery.datatables中文帮助文档_奎宇工作室 jQuery EasyUI 1.3 中文文档--首页 jQuery EasyUI 1.3 中文文档--数据表格和树形菜单[data and tree] 极检验证码 极验验证 pdf.js预览 pdf.js - mmrsdym的专栏 - 博客频道 - CSDN.NET pdf.js使用教程 - 推酷 App开发 Ionic_中国最大的ionic/ionicframework中文视频教程分享网 Overview - APICloud Docs PHP 第一PHP社区 - PHP1.CN 国内最大的PHP中文社区 PHP - MySQL 数据库函数库 VPN 腾讯云win2008搭建pptp VPN的简单步骤-腾讯云官方论坛 免费VPN帐号-月光微博客 LoCoJSQ官网_高品质VPN代理首选_LoCoJSQ网络加速器_LoCoVPN 配置win10专用虚拟网络时提示已拒绝远程连接解决办法－系统城·电脑系统下载之家 启用Windows 路由和远程访问实现VPN虚拟拨号 - NULL 博客 - 博客频道 - CSDN.NET 优化 完整攻略！让你的网页加载时间降低到 1s 内！ - 简书 Node.Js express-使用supervisor提高nodejs调试效率 - 穆乙 - 博客园 纯异步nodejs文件夹(目录)复制 - faylai - ITeye技术网站 ECMAScript 6简介 - ECMAScript 6入门 ECMAScript 6简介 - ECMAScript 6入门 Express - 基于 Node.js 平台的 web 应用开发框架 React windows下搭建react-native踩过的坑 - 推酷 海马玩模拟器——搭建React Native环境 - 小白林宇风 - 博客频道 - CSDN.NET [新手提问前先来这里看看]React Native的常见问题 | 论坛 - React Native中文社区 搭建开发环境 - React Native 中文网 React-native for android——环境搭建及问题处理 - rainmeterlinux的专栏 - 博客频道 - CSDN.NET 史上最全Windows版本搭建安装React Native环境配置 - suxun - 博客园 ReactNative的Navigator组件使用方式 - 简书 Java Android JDK 下载-百度网盘下载连接/保存/分享 Vue WEEX技术分享社区 阿里巴巴开源前端框架--Weex实践 - zhangcanyan的博客 - 博客频道 - CSDN.NET 文学 T文学网-诗歌散文_小说日记_随笔笑话-文学爱好者的文天堂! 留有一份安详已足够_墨迹坊文学网 社区 开源 在线工具 —— 开源中国社区 GetWeApp - 微信小程序学习社群 开源中国 - 找到您想要的开源项目，分享和交流 Git@OSC代码托管-开源中国社区 学习 汇智网 - 最前沿的在线互动编程学习平台 极客学院IT在线教育平台-中国最大的IT职业在线教育平台 传智播客公开课 猿团教育 - 猿团教育_猿团教育IT在线教育平台 - Powered By EduSoho 博学谷视频库-免费提供java视频,大数据视频,web前端视频,php视频,C/C++视频,iOS视频,网页设计视频,平面设计视频,UI设计视频,游戏开发视频,网络营销视频 网站开发教程大全 - 在线手册 - 参考手册 - 手册网 6座网_免费的职业规划网站 菜鸟教程 - 学的不仅是技术，更是梦想！ 有道云笔记 w3cschool - 学技术查资料，从w3cschool开始! 娱乐 暗组技术论坛-从心出发改变未来 - Powered by Discuz! Tumblr 我的小米云服务804162996 FreeBuf.COM | 关注黑客与极客 蒲公英 - 免费的应用托管平台|App应用众测分发 i春秋学院 伯乐在线 中国领先的创业创新服务平台_i黑马 图灵社区—图灵机器人官方论坛 - Powered by 图灵机器人 维基百科，自由的百科全书 问答 Stack Overflow SegmentFault 全栈 Microsoft API 和参考目录 V2EX 零度-分享编程之美 熱門文章 - 點部落 如鹏网免费视频教程——Java视频教程，.Net视频教程，Android视频教程 HttpHelper官方站-苏飞论坛 CSDN论坛 Orchard 中文 - 为何选择 Orchard？ API数据接口_开发者数据定制_免费数据调用-聚合数据 前端 前端网（W3Cfuns） - 前端开发工程师互动平台 React Native 中文网 Hexo Bootstrap模板,后台模板,html5模板,响应式模板,商城模板 - jQueryfuns 介绍 - vue.js w3cplus_引领web前沿，打造前端精品教程 MUI - DCloud 模板之家 懒人图库 H+ 后台主题UI框架 - 主页 中国素材网站_素材中国psd_素材天下psd_素材天下-素材中国17素材网 HTML5资源教程 | 分享HTML5开发资源和开发教程 www.h-ui.net 前端收藏夹 jQueryfunsBootstrap后台模板,管理模板,响应式模板,手机模板,jquery特效,jquery - 深入响应式原理 - vue.js 常用网站 博客园 - 开发者的网上家园 GitHub yimogit Coding | 代码托管，项目管理，WebIDE，演示部署，开启云端开发模式，让开发更简单 我的首页 微博 百度贴吧 人人都是产品经理 | 产品经理、产品爱好者学习交流平台 掘金 UI中国-专业界面交互设计平台 哔哩哔哩弹幕视频网 - ( ゜- ゜)つロ 乾杯~ - bilibili 首页 - 知乎 VIP 电影免费看 - 不要 VIP 照样看大片,一键解析爱奇艺,优酷,腾讯,乐视,芒果等各大视频网站的 VIP 视频 Google Bing 百度一下 找找看 百度一下 采集到花瓣"}],"posts":[{"title":"使用travis-ci集成一个vue.js项目","permalink":"https://yimogit.github.io/2017/07/24/使用travis-ci自动部署github上的项目/","text":"travis-ci是什么？ 一个使用yaml格式配置用于持续集成完成自动化测试部署的开源项目官网：https://travis-ci.org/ 使用travis-ci集成vue.js项目 首先，您需要一个github账号 and 一个vue.js项目~ 没有的话试试这个啊metools 1. 登录Github并拥有一个项目 登录github 然后Star,Fork metools当然可以先去看看这个项目是啥..http://tools.yimo.link/ 2. 前往travis-ci官网 使用Github账号登录 3. 登录成功回到用户中心 默认会同步一部分仓库，如果太多的话需要点击Sync account进行同步 4. 开启对 metools 项目的集成并进入设置页面 如下图所示，根据需要配置构建信息添加github的Token到环境变量中，用户名，邮箱也可添加进去，这样配置文件中就可以使用了生成Token见步骤5.因为github上面只能看到一次，所以在travis-ci中就可以显示出来以备后用根据步骤6的配置，还需要添加一些环境变量使起更方便(地址别填错了)图中配置依次为： GH_REF：仓库地址 GH_TOKEN：生成的令牌 P_BRANCH：推送的pages分支 U_EMAIL：邮箱 U_NAME：名称 5. Github生成访问令牌 (即添加授权) 访问令牌的作用就是授权仓库操作权限 https://github.com/settings/tokensGithub&gt;settings&gt;Personal access tokens&gt; Generate new token &gt; Generate token&gt; Copy Token 6. .travis.yml 文件的简单配置 .travis.yml文件的作用就是在代码提交的时候travis-ci会根据该配置文件执行配置的任务在项目根目录中创建(或修改).travis.yml 文件，其中${环境变量}为环境变量在travis中配置即可1234567891011121314151617181920212223242526272829303132333435363738language: node_js# nodejs版本node_js: - '6'# Travis-CI Cachingcache: directories: - node_modules# S: Build Lifecycleinstall: - npm installbefore_script:# 无其他依赖项所以执行npm run build 构建就行了script: - npm run buildafter_script: - cd ./dist - git init - git config user.name \"$&#123;U_NAME&#125;\" - git config user.email \"$&#123;U_EMAIL&#125;\" - git add . - git commit -m \"Update tools\" - git push --force --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" master:$&#123;P_BRANCH&#125;# E: Build LifeCyclebranches: only: - masterenv: global: # 我将其添加到了travis-ci的环境变量中 #- GH_REF: github.com/yimogit/metools.git 7. 自动构建项目修改完成，并推送到github后，就可以在travis-ci.org中看到项目开始构建了(以后每次推送代码到仓库后都将会自动构建项目)构建完成日志 构建完成。在设置中可以看到默认已经将gh-pages分支部署到pages，访问https://用户名.github.io/metools/即可预览效果。 若构建失败，可以通过travis-ci中项目面板右上角的 Restart build 重新构建"},{"title":"asp.net mvc项目实记","permalink":"https://yimogit.github.io/2017/07/19/asp.net mvc项目实记/","text":"百度这些东西，还是会浪费了一些不必要的时间，记录记录以备后续 一、开启伪静态 如果不在web.config中配置管道开关则伪静态无效 首先在RouteConfig.cs中中注册路由 12345routes.MapRoute( name: &quot;index&quot;, url: &quot;index.html&quot;, defaults: new &#123; controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional &#125;); 在web.config中的system.webServer节点添加配置项 123&lt;system.webServer&gt; &lt;modules runAllManagedModulesForAllRequests=&quot;true&quot; /&gt;&lt;/system.webServer&gt; 二、使用Bundle压缩css,js 添加Nuget包Microsoft.AspNet.Web.Optimization 配置BundleConfig.cs文件 12345678910111213141516171819public class BundleConfig&#123; public static void RegisterBundles(BundleCollection bundles) &#123; //若runAllManagedModulesForAllRequests未配置则不不能使用.css，.js等带后缀的静态资源名称，反之即可 bundles.Add(new StyleBundle(&quot;~/Content/maincss&quot;).Include( &quot;~/Content/assets/css/main.css&quot;, &quot;~/Content/assets/css/md.css&quot; )); bundles.Add(new ScriptBundle(&quot;~/Content/listjs&quot;).Include( &quot;~/Content/assets/js/xss.js&quot;, &quot;~/Content/assets/js/meMd.js&quot;, &quot;~/Content/assets/js/marked.js&quot;, &quot;~/Content/assets/js/dragscroll.js&quot; )); //强制开启压缩，或者由system.web节点的compilation【debug】值控制(即debug模式下不压缩合并) //BundleTable.EnableOptimizations = true; &#125;&#125; 在Global.asax的Application_Start()中注册配置 BundleConfig.RegisterBundles(BundleTable.Bundles); 需要注意的地方 StyleBundle构造函数中的路径为虚拟路径，即不用关心目录是否存在 若web.config中配置了&lt;modules runAllManagedModulesForAllRequests=&quot;true&quot; /&gt;，则序StyleBundle传递的虚拟路径可以包含后缀名.css/.js Bundle压缩合并功能可由web.config中的system.web节点下&lt;compilation debug=&quot;false&quot; targetFramework=&quot;4.5&quot; /&gt;的debug值控制，或者在RegisterBundles方法中强制启用：BundleTable.EnableOptimizations = true; 三、layui富文本编辑器中的文件上传接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class FileController : Controller&#123; private static readonly string[] ImageFileExtensions = GetConfigValue(&quot;ImgExts&quot;).Split(&apos;,&apos;) ?? new string[] &#123; &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.ico&quot; &#125;; private static readonly string ImageDomain = GetConfigValue(&quot;ImgDomain&quot;);//末尾不带/ private static readonly string UploadDir = GetConfigValue(&quot;UploadDir&quot;, &quot;/uploads/&quot;);//相对路径吧 private static readonly int UploadMaxLength = int.Parse(GetConfigValue(&quot;UploadMaxLength&quot;, &quot;5242880&quot;));//默认最大5M private static string GetConfigValue(string key, string def = &quot;&quot;) &#123; return System.Configuration.ConfigurationManager.AppSettings[key] ?? def; &#125; [HttpPost] public ActionResult Upload(HttpPostedFileBase file) &#123; if (file == null) &#123; return Json(new &#123; code = -1, msg = &quot;未上传任何东西！&quot; &#125;); &#125; if (file.ContentLength &gt; UploadMaxLength) &#123; return Json(new &#123; code = -1, msg = &quot;文件大小不能超过5M！&quot; &#125;); &#125; string ext = Path.GetExtension(file.FileName); if (ImageFileExtensions.Any(e =&gt; e == ext)) &#123; return Json(new &#123; code = -1, msg = &quot;不支持此文件格式&quot; &#125;); &#125; string fileName = Guid.NewGuid().ToString() + ext; string saveDir = System.Web.HttpContext.Current.Request.MapPath(UploadDir); if (!Directory.Exists(saveDir)) &#123; Directory.CreateDirectory(saveDir); &#125; string savePath = Path.Combine(saveDir, fileName); file.SaveAs(savePath); return Json(new &#123; code = 0, msg = &quot;上传成功&quot;, data = new &#123; src = ImageDomain + UploadDir + fileName, title = &quot;&quot; &#125; &#125;); &#125;&#125; 四、使用js-xss进行xss的防御 保存xss.js到本地并在页面中引用 使用filterXss(html,options)调用函数处理，根据规则将规则内的html编码 123// 使用函数名 filterXSS，用法一样var html = filterXSS('&lt;script&gt;alert(\"xss\");&lt;/script&gt;');console.log(html);//\"&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt;\" 实际使用 执行结果对比 123456789101112131415//定义自己的规则var myXssOptions = function (isEditer) &#123; return &#123; onTagAttr: function (tag, name, value, isWhiteAttr) &#123; //保留style标签 默认会将style给干掉 if (name == 'style') &#123; return \"style='\" + value + \"'\"; &#125; //替换src为lay-src做懒加载 if (!isEditer &amp;&amp; tag == 'img' &amp;&amp; name == 'src') &#123; return \"lay-src='\" + value + \"'\"; &#125; &#125; &#125;&#125;;"},{"title":"一个简单的时间轴demo","permalink":"https://yimogit.github.io/2017/07/18/一个简单的时间轴demo/","text":"一个时间轴的组成 使用一个块级元素包裹内容，并未块级元素设置边框 定义圆形或者菱形等元素标签，子元素设置偏移或者定位元素将图标定位到边框上 使其中的内容不溢出，自动换行，内容自动撑高 英文自动换行：word-wrap:break-word;word-break:break-all 时间轴样式部分 使用时需要注意可能继承的样式会给li:after等伪类元素设置样式而造成效果异常css中定义了一个圆形的图标class=&quot;yuan&quot;，一个菱形的图标class=&quot;diamond&quot; 123456789101112131415 &lt;style&gt; body&#123;font:12px\"宋体\",\"Arial Narrow\",HELVETICA;background:#fff;-webkit-text-size-adjust:100%&#125; .ym-timeline&#123;display:block&#125; .ym-timeline ul&#123;margin-left:30px;border-left:2px solid green;padding:0&#125; .ym-timeline ul li&#123;width:100%;margin-left:-12px;line-height:20px;font-weight:narmal;list-style:none&#125; /*圆形图标*/ .ym-timeline ul li span.yuan&#123;width:8px;height:8px;background:#fff;border:2px solid green;margin:5px;border-radius:6px;-webkit-border-radius:6px;-moz-border-radius:6px;overflow:hidden;display:inline-block;float:left&#125; /*菱形图标*/ .ym-timeline ul li span.diamond&#123;width:8px;height:8px;background:#fff;border:2px solid green;margin:5px;overflow:hidden;display:inline-block;float:left;transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-webkit-transform:rotate(45deg);-o-transform:rotate(45deg)&#125; .ym-timeline ul li span.stime&#123;padding-left:7px;font-size:12px;line-height:20px;color:green&#125; .ym-timeline ul li .ym-tl-content&#123;padding:10px 0 10px 20px;font-size:14px;line-height:25px;word-wrap:break-word;word-break:break-all&#125; .ym-timeline ul li:first-child span.diamond,.ym-timeline ul li:first-child span.yuan&#123;margin-top:0&#125; .ym-timeline ul li:last-child span.diamond,.ym-timeline ul li:last-child span.yuan&#123;margin-top:8px&#125; .ym-timeline ul li .ym-tl-content img&#123;max-width:100%;&#125;&lt;/style&gt; 时间轴html结构12345678910111213141516171819202122&lt;!--效果预览http://runjs.cn/code/6udflsbt--&gt;&lt;div class=\"ym-timeline\"&gt; &lt;ul&gt; &lt;li&gt; &lt;span class=\"diamond\"&gt;&lt;/span&gt; &lt;span class=\"stime\"&gt;2017-07-17&lt;/span&gt; &lt;div class=\"ym-tl-content\"&gt; 是开始 ttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttestt 亦是结束 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"diamond\"&gt;&lt;/span&gt; &lt;span class=\"stime\"&gt;2017-07-18&lt;/span&gt; &lt;div class=\"ym-tl-content\"&gt; 是开始 ttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttestt 亦是结束 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"diamond\"&gt;&lt;/span&gt; &lt;span class=\"stime\"&gt;2017-07-19&lt;/span&gt; &lt;div class=\"ym-tl-content\"&gt; 是开始 ttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttestt 亦是结束 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"diamond\"&gt;&lt;/span&gt; &lt;span class=\"stime\"&gt;2017-07-20&lt;/span&gt; &lt;div class=\"ym-tl-content\"&gt; 是开始 ttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest testtesttesttesttesttesttesttesttesttesttestt 亦是结束 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"yuan\"&gt;&lt;/span&gt; &lt;span class=\"stime\"&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 效果预览 完整代码"},{"title":"asp.net-core踩坑记录","permalink":"https://yimogit.github.io/2017/07/09/asp.net-core踩坑记录/","text":"系统：win10VS版本：2017.NET Core 版本： 1.1 零.读取配置文件 参考：http://www.tuicool.com/articles/QfYVBvi 此版本无需添加其他组件 在appsettings.json配置中添加节点AppSettings 添加配置文件的映射模型 在Startup.cs ConfigureServices方法中注册 services.AddOptions(); services.Configure&lt;AppSettings&gt;(Configuration.GetSection(&quot;AppSettings&quot;)); Controller中使用 一、登录记录session 参考：http://www.cnblogs.com/fonour/p/5943401.html 二、发布.net core1.1.2网站到windos服务器 参考：https://docs.microsoft.com/en-us/aspnet/core/publishing/iis 我的服务器是windows server 2012 ,.net core网站版本为1.1.2 经安装好iis 下载安装： .NET Core Windows Server Hosting Microsoft Visual C++ 2015 Redistributable Update 3 发布.net core网站到IIS，并将应用池的.NET CLR版本修改为[无托管代码] 三、DES加密解密算法 亲测可用 public class SecurityHelper { #region 加密解密法一 //默认密钥向量 private static byte[] Keys = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }; /// &lt;summary&gt; /// DES加密字符串 /// &lt;/summary&gt; /// &lt;param name=&quot;encryptString&quot;&gt;待加密的字符串&lt;/param&gt; /// &lt;param name=&quot;encryptKey&quot;&gt;加密密钥,要求为16位&lt;/param&gt; /// &lt;returns&gt;加密成功返回加密后的字符串，失败返回源串&lt;/returns&gt; public static string EncryptDES(string encryptString, string encryptKey = &quot;Key123Ace#321Key&quot;) { try { byte[] rgbKey = Encoding.UTF8.GetBytes(encryptKey.Substring(0, 16)); byte[] rgbIV = Keys; byte[] inputByteArray = Encoding.UTF8.GetBytes(encryptString); var DCSP = Aes.Create(); MemoryStream mStream = new MemoryStream(); CryptoStream cStream = new CryptoStream(mStream, DCSP.CreateEncryptor(rgbKey, rgbIV), CryptoStreamMode.Write); cStream.Write(inputByteArray, 0, inputByteArray.Length); cStream.FlushFinalBlock(); return Convert.ToBase64String(mStream.ToArray()); } catch (Exception ex) { return ex.Message + encryptString; } } /// &lt;summary&gt; /// DES解密字符串 /// &lt;/summary&gt; /// &lt;param name=&quot;decryptString&quot;&gt;待解密的字符串&lt;/param&gt; /// &lt;param name=&quot;decryptKey&quot;&gt;解密密钥,要求为16位,和加密密钥相同&lt;/param&gt; /// &lt;returns&gt;解密成功返回解密后的字符串，失败返源串&lt;/returns&gt; public static string DecryptDES(string decryptString, string decryptKey = &quot;Key123Ace#321Key&quot;) { try { byte[] rgbKey = Encoding.UTF8.GetBytes(decryptKey.Substring(0, 16)); byte[] rgbIV = Keys; byte[] inputByteArray = Convert.FromBase64String(decryptString); var DCSP = Aes.Create(); MemoryStream mStream = new MemoryStream(); CryptoStream cStream = new CryptoStream(mStream, DCSP.CreateDecryptor(rgbKey, rgbIV), CryptoStreamMode.Write); Byte[] inputByteArrays = new byte[inputByteArray.Length]; cStream.Write(inputByteArray, 0, inputByteArray.Length); cStream.FlushFinalBlock(); return Encoding.UTF8.GetString(mStream.ToArray()); } catch (Exception ex) { return ex.Message + decryptString; } } #endregion } 四、过滤器定义 继承Attribute,实现IActionFilter即可简单校验登录,获取cookie值并解密后得到用户名,未登录则跳转登录(ApplicationKey为自定义的类存放) public class UserCheckFilterAttribute : Attribute, IActionFilter { public void OnActionExecuted(ActionExecutedContext context) { } public void OnActionExecuting(ActionExecutingContext filterContext) { string encryptValue = &quot;&quot;; filterContext.HttpContext.Request.Cookies.TryGetValue(ApplicationKey.User_Cookie_Key, out encryptValue); if (encryptValue == null) { filterContext.Result = new RedirectResult(&quot;/Account/Login&quot;); return; } var userName = SecurityHelper.DecryptDES(encryptValue, ApplicationKey.User_Cookie_Encryption_Key); if (string.IsNullOrEmpty(userName)) { filterContext.Result = new RedirectResult(&quot;/Account/Login&quot;); return; } } } 注入服务 Startup.cs中的ConfigureServices方法调用services.AddTransient&lt;IUserService,UserService&gt;();注册服务"},{"title":"winform复制文件到指定目录","permalink":"https://yimogit.github.io/2017/07/05/winform复制文件到指定目录/","text":"执行步骤 弹出选择对话框：var openFileDialog = new OpenFileDialog(); 设置选择内容,如所有图片:openFileDialog.Filter=&quot;图像文件 (*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png)|*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png&quot;; 获取选择的路径集合：openFileDialog.FileNames 复制文件:File.Copy(sourcePath,targetPath);//目录重命名见下面代码 1. 打开图片选择对话框 默认为多选，返回选择的文件路径集合，可使用FirstOrDefault()方法判断是否选择了文件 //打开文件对话框并获取选择的文件 private List&lt;string&gt; OpenImagesDialog(bool isMulti = true) { var openFileDialog = new OpenFileDialog(); const string imgExts = &quot;图像文件 (*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png)|*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png&quot;; openFileDialog.Filter = imgExts;//可选择的文件格式 (|之前为显示，之后为控制后缀显示) openFileDialog.Multiselect = isMulti;//多选设置 openFileDialog.RestoreDirectory = true; openFileDialog.FilterIndex = 1; var result = new List&lt;string&gt;(); if (openFileDialog.ShowDialog() == DialogResult.OK) { result.AddRange(openFileDialog.FileNames); } return result; } 2.复制文件到指定目录 将传递的文件复制到指定目录并以Guid重命名，目录不存在则自动创建使用元组返回对应路径键值对(Item1)及失败路径集合(Item2) /// &lt;summary&gt; /// 复制文件到指定目录并重命名 /// &lt;/summary&gt; /// &lt;param name=&quot;sourcePaths&quot;&gt;要复制的文件路径集合&lt;/param&gt; /// &lt;param name=&quot;targetDir&quot;&gt;目标目录&lt;/param&gt; /// &lt;returns&gt;Item1:对应路径，Item2:失败文件路径&lt;/returns&gt; public static Tuple&lt;Dictionary&lt;string, string&gt;, List&lt;string&gt;&gt; CopyFileToDir(List&lt;string&gt; sourcePaths, string targetDir) { if (!Directory.Exists(targetDir)) { Directory.CreateDirectory(targetDir); } var errorFiles = new List&lt;string&gt;(); var saveDirs = new Dictionary&lt;string, string&gt;(); sourcePaths.ForEach(item =&gt; { //路径不存在或者路径已存在则失败 if (!File.Exists(item) || saveDirs.ContainsKey(item)) { errorFiles.Add(item); } else { var saveName = Guid.NewGuid() + Path.GetExtension(item); var savePath = Path.Combine(targetDir, saveName); File.Copy(item, savePath); saveDirs.Add(item, savePath); } }); var result = new Tuple&lt;Dictionary&lt;string, string&gt;, List&lt;string&gt;&gt;(saveDirs, errorFiles); return result; } 调用示例 ( AppendLogMsg 为追加日志方法) var selectImgs = OpenImagesDialog(true);//打开文件对话框并获取选择的所有文件 var result = FileHelper.CopyFileToDir(selectImgs, txtSaveDir.Text); //result.Item1 [{源文件路径:目标路径}] //result.Item2 [失败路径1,失败路径2]"},{"title":"winform制作小工具的技巧","permalink":"https://yimogit.github.io/2017/07/05/winform制作小工具的技巧/","text":"在使用winfrom制作一些工具的时候，一些基本设置都是去属性里面找来找去，一段时间就忘了，记录记录以备不时之需。 一、窗体绘制的常用设置 窗体的设置应当在窗体构造函数中InitializeComponent()方法前执行 public frmMain() { this.StartPosition = FormStartPosition.CenterScreen;//窗体居中显示 this.MaximizeBox = false;//不显示最大化按钮 this.FormBorderStyle = FormBorderStyle.FixedSingle;//禁止放大缩小 InitializeComponent(); } 二、winform文本框全选功能 Control_ControlAdded事件在InitializeComponent()调用之前注册 public frmMain() { this.ControlAdded += new System.Windows.Forms.ControlEventHandler(this.Control_ControlAdded); InitializeComponent(); } private void Control_ControlAdded(object sender, ControlEventArgs e) { //使“未来”生效 e.Control.ControlAdded += new System.Windows.Forms.ControlEventHandler(this.Control_ControlAdded); //使“子孙”生效 foreach (Control c in e.Control.Controls) { Control_ControlAdded(sender, new ControlEventArgs(c)); } //使“过去”生效 TextBox textBox = e.Control as TextBox; if (textBox != null) { textBox.KeyPress += TextBox_KeyPress; } } private void TextBox_KeyPress(object sender, KeyPressEventArgs e) { TextBox textBox = sender as TextBox; if (textBox == null) return; if (e.KeyChar == (char)1) { textBox.SelectAll(); e.Handled = true; } } 三、设置一个显示日志的文本框 首先在页面中放置一个文本框，设置Multiline=true后拖动到合适大小然后在加载事件中进行设置 private static int _maxLogmsgTextLength = 10000;//日志框最大输入 private void frmMain_Load(object sender, EventArgs e) { this.txtLogMsg.Multiline = true;//多选， 一般在界面中就设置了 this.txtLogMsg.ScrollBars = ScrollBars.Vertical;//日志输出显示纵向滚动条 this.txtLogMsg.ReadOnly = true; //输出日志只读 this.txtLogMsg.TextChanged += txtLogMsg_TextChanged;//注册改变事件 int.TryParse(System.Configuration.ConfigurationManager.AppSettings[&quot;MAX_LOGMSG_TEXT_LENGTH&quot;], out _maxLogmsgTextLength);//优先使用配置文件配置的值 } //文本框事件 使追加日志后滚动光标到末尾 void txtLogMsg_TextChanged(object sender, EventArgs e) { txtLogMsg.SelectionStart = txtLogMsg.Text.Length + 10;//设置选中文字的开始位置为文本框的文字的长度，如果超过了文本长度，则默认为文本的最后。 txtLogMsg.SelectionLength = 0;//设置被选中文字的长度为0（将光标移动到文字最后） txtLogMsg.ScrollToCaret();//将滚动条移动到光标位置 } //追加日志方法 在非UI线程中直接AppendText调试会异常 private void AppendLogMsg(string msg) { //在UI线程中执行 txtLogMsg.BeginInvoke(new Action(() =&gt; { txtLogMsg.AppendText(msg); txtLogMsg.AppendText(Environment.NewLine);//追加换行符 })); } 四、开启一个线程执行任务 避免界面卡死 var askThread=new Thread(() =&gt; { //TODO //AppendLogMsg(&quot;添加日志,调试时不会报错~~~&quot;); } askThread.Start(); //.NET Framework 4.5+ //Task.Run(()=&gt;{ // //TODO //}) 五、打开图片选择对话框 默认为多选，返回选择的文件路径集合，可使用FirstOrDefault()方法判断是否选择了文件 private List&lt;string&gt; OpenImagesDialog(bool isMulti = true) { var openFileDialog = new OpenFileDialog(); const string imgExts = &quot;图像文件 (*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png)|*.bmp;*.ico;*.gif;*.jpeg;*.jpg;*.png&quot;; openFileDialog.Filter = imgExts; openFileDialog.Multiselect = isMulti; openFileDialog.RestoreDirectory = true; openFileDialog.FilterIndex = 1; var result = new List&lt;string&gt;(); if (openFileDialog.ShowDialog() == DialogResult.OK) { result.AddRange(openFileDialog.FileNames); } return result; } 六、复制文件到指定目录 将传递的文件复制到指定目录并以Guid重命名，目录不存在则自动创建使用元组返回对应路径键值对(Item1)及失败路径集合(Item2) /// &lt;summary&gt; /// 复制文件到指定目录并重命名 /// &lt;/summary&gt; /// &lt;param name=&quot;sourcePaths&quot;&gt;要复制的文件路径集合&lt;/param&gt; /// &lt;param name=&quot;targetDir&quot;&gt;目标目录&lt;/param&gt; /// &lt;returns&gt;Item1:对应路径，Item2:失败文件路径&lt;/returns&gt; public static Tuple&lt;Dictionary&lt;string, string&gt;, List&lt;string&gt;&gt; CopyFileToDir(List&lt;string&gt; sourcePaths, string targetDir) { if (!Directory.Exists(targetDir)) { Directory.CreateDirectory(targetDir); } var errorFiles = new List&lt;string&gt;(); var saveDirs = new Dictionary&lt;string, string&gt;(); sourcePaths.ForEach(item =&gt; { //路径不存在或者路径已存在则失败 if (!File.Exists(item) || saveDirs.ContainsKey(item)) { errorFiles.Add(item); } else { var saveName = Guid.NewGuid() + Path.GetExtension(item); var savePath = Path.Combine(targetDir, saveName); File.Copy(item, savePath); saveDirs.Add(item, savePath); } }); var result = new Tuple&lt;Dictionary&lt;string, string&gt;, List&lt;string&gt;&gt;(saveDirs, errorFiles); return result; } 调用示例 ( AppendLogMsg 为追加日志方法) var selectImgs = OpenImagesDialog(true);//五、打开图片选择对话框方法 var result = FileHelper.CopyFileToDir(selectImgs, txtSaveDir.Text); result.Item1.Keys.ToList().ForEach(item =&gt; AppendLogMsg(item + &quot;:&quot; + result.Item1[item]));//成功时输出 result.Item2.ForEach(item =&gt; AppendLogMsg(&quot;文件复制失败：&quot; + item));//文件错误输出 七、使用Ini文件存取配置 保存一些配置到ini文件，是自己的工具更佳灵活 ini操作类public class IniHelper { // 声明INI文件的写操作函数 WritePrivateProfileString() [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern long WritePrivateProfileString(string section, string key, string val, string filePath); // 声明INI文件的读操作函数 GetPrivateProfileString() [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern int GetPrivateProfileString(string section, string key, string def, System.Text.StringBuilder retVal, int size, string filePath); private readonly int _retLength = 500; private readonly string _sPath = null; /// &lt;summary&gt; /// 初始化IniHelper /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;ini文件保存路径&lt;/param&gt; /// &lt;param name=&quot;rl&quot;&gt;默认500&lt;/param&gt; public IniHelper(string path, int? rl = null) { this._sPath = path; this._retLength = rl.HasValue ? rl.Value : _retLength; } /// &lt;summary&gt; /// 设置Ini配置，默认配置节为Setting /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;键名&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;键值&lt;/param&gt; /// &lt;param name=&quot;section&quot;&gt;配置节&lt;/param&gt; public void WriteValue(string key, string value, string section = &quot;Setting&quot;) { // section=配置节，key=键名，value=键值，path=路径 WritePrivateProfileString(section, key, value, _sPath); } /// &lt;summary&gt; /// 根据键名节点读取Ini配置，默认节点为Setting /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;键名&lt;/param&gt; /// &lt;param name=&quot;section&quot;&gt;配置节&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string ReadValue(string key, string section = &quot;Setting&quot;) { // 每次从ini中读取多少字节 System.Text.StringBuilder temp = new System.Text.StringBuilder(_retLength); // section=配置节，key=键名，temp=上面，path=路径 GetPrivateProfileString(section, key, &quot;&quot;, temp, _retLength, _sPath); return temp.ToString(); } } IniHelper使用示例string savePath = AppDomain.CurrentDomain.BaseDirectory + &quot;config.ini&quot;; IniHelper _iniHelper = new IniHelper(savePath);//初始化 _iniHelper.WriteValue(&quot;txtGitAddress&quot;);//写入 _iniHelper.ReadValue(&quot;txtGitAddress&quot;);//读取 其他 调用本地程序：System.Diagnostics.Process.Start(&quot;E:\\\\程序.exe&quot;, &quot;c:\\\\windows&quot;);打开目录：System.Diagnostics.Process.Start(&quot;Explorer.exe&quot;, “目录路径E:\\abc\\”);"},{"title":"meImgs-个人私有图床搭建","permalink":"https://yimogit.github.io/2017/07/04/meImgs-个人私有图床搭建/","text":"在Coding中新建一个仓库"},{"title":"大话数据结构-阅读笔记","permalink":"https://yimogit.github.io/2017/07/02/大话数据结构笔记/","text":"数据结构果然还是应该知道一点为好 2017-06-30日 第一章介绍数据结构结构是指各个组成部分相互搭配和排列的方式数据结构就是相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构对象中数据元素之间的相互关系包含 : 集合结构，线性结构，树形结构，图形结构 物理结构指数据的逻辑结构在计算机中的存储形式包含 : 顺序存储结构，链接存储结构"},{"title":"db数据导出Excel工具","permalink":"https://yimogit.github.io/2017/07/02/db数据导出Excel工具/","text":"一个根据数据库链接字符串，sql语句 即可将结果集导出到Excel的工具 分享，支持sqlserver,mysql。 前因 一个月前朋友找到我，让我帮忙做一个根据sql导出查询结果到Excel的工具（之前帮他一个导入Excel然后按其规则统计数据的工具）。然后扔了我一个SQL语句，瞬间懵比。卧槽。这么多列，我特么得定义这么属性，改了还得重新改程序（一直用EF）。于是思考如何忽略列名，进而如何做到通用，做到于我有益，而不是简单的帮个忙。 如何完成这个需求 Q:程序中根据SQL查询出数据而不需要关注有哪些列？A:将查询结果保存到DataTable中然后遍历Q:如何将DataTable转换Excel？A:一搜，一试，可用之Q:如何保存到本地？A:待我改改写日志的方法使用SqlSugar 4.x 进行数据操作SqlSugar 4.x是一款高性能（达到ADO.NET最高性能水平）、轻量级、支持多库和人性化语法的ORM，语法方便，入门简单，功能强大。对数据库结构没太多要求，支持多主键，多自增列SqlSugar支持sqlserver,mysql故此工具适用于此两者数据库 0. 创建项目-预览 1. 到github仓库clone了源码至本地生成需要的dll，然后在项目中添加了引用 2. 使用SqlSugar获取结果到DataTable中(不知道是不是最近帮朋友写ado.net的代码写多了，感觉挺好) 3. DataTable转Excelpublic class DataTableToExcel { private DataTableToExcel() { } private static DataTableToExcel _instance = null; public static DataTableToExcel Instance { get { if (_instance == null) _instance = new DataTableToExcel(); return _instance; } } /// &lt;summary&gt; /// DataTable通过流导出Excel /// &lt;/summary&gt; /// &lt;param name=&quot;ds&quot;&gt;数据源DataSet&lt;/param&gt; /// &lt;param name=&quot;columns&quot;&gt;DataTable中列对应的列名(可以是中文),若为null则取DataTable中的字段名&lt;/param&gt; /// &lt;param name=&quot;fileName&quot;&gt;保存文件名(例如：a.xls)&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string StreamExport(DataTable dt, string[] columns = null,string savePath=&quot;&quot;) { //if (dt.Rows.Count &gt; 65535) //总行数大于Excel的行数 //{ // throw new Exception(&quot;预导出的数据总行数大于excel的行数&quot;); //} StringBuilder content = new StringBuilder(); content.Append(&quot;&lt;html xmlns:o=&apos;urn:schemas-microsoft-com:office:office&apos; xmlns:x=&apos;urn:schemas-microsoft-com:office:excel&apos; xmlns=&apos;http://www.w3.org/TR/REC-html40&apos;&gt;&quot;); content.Append(&quot;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta http-equiv=&apos;Content-Type&apos; content=\\&quot;text/html; charset=gb2312\\&quot;&gt;&quot;); //注意：[if gte mso 9]到[endif]之间的代码，用于显示Excel的网格线，若不想显示Excel的网格线，可以去掉此代码 content.Append(&quot;&lt;!--[if gte mso 9]&gt;&quot;); content.Append(&quot;&lt;xml&gt;&quot;); content.Append(&quot; &lt;x:ExcelWorkbook&gt;&quot;); content.Append(&quot; &lt;x:ExcelWorksheets&gt;&quot;); content.Append(&quot; &lt;x:ExcelWorksheet&gt;&quot;); content.Append(&quot; &lt;x:Name&gt;Sheet1&lt;/x:Name&gt;&quot;); content.Append(&quot; &lt;x:WorksheetOptions&gt;&quot;); content.Append(&quot; &lt;x:Print&gt;&quot;); content.Append(&quot; &lt;x:ValidPrinterInfo /&gt;&quot;); content.Append(&quot; &lt;/x:Print&gt;&quot;); content.Append(&quot; &lt;/x:WorksheetOptions&gt;&quot;); content.Append(&quot; &lt;/x:ExcelWorksheet&gt;&quot;); content.Append(&quot; &lt;/x:ExcelWorksheets&gt;&quot;); content.Append(&quot;&lt;/x:ExcelWorkbook&gt;&quot;); content.Append(&quot;&lt;/xml&gt;&quot;); content.Append(&quot;&lt;![endif]--&gt;&quot;); content.Append(&quot;&lt;/head&gt;&lt;body&gt;&lt;table style=&apos;border-collapse:collapse;table-layout:fixed;&apos;&gt;&lt;tr&gt;&quot;); if (columns != null) { for (int i = 0; i &lt; columns.Length; i++) { if (columns[i] != null &amp;&amp; columns[i] != &quot;&quot;) { content.Append(&quot;&lt;td&gt;&lt;b&gt;&quot; + columns[i] + &quot;&lt;/b&gt;&lt;/td&gt;&quot;); } else { content.Append(&quot;&lt;td&gt;&lt;b&gt;&quot; + dt.Columns[i].ColumnName + &quot;&lt;/b&gt;&lt;/td&gt;&quot;); } } } else { for (int j = 0; j &lt; dt.Columns.Count; j++) { content.Append(&quot;&lt;td&gt;&lt;b&gt;&quot; + dt.Columns[j].ColumnName + &quot;&lt;/b&gt;&lt;/td&gt;&quot;); } } content.Append(&quot;&lt;/tr&gt;\\n&quot;); for (int j = 0; j &lt; dt.Rows.Count; j++) { content.Append(&quot;&lt;tr&gt;&quot;); for (int k = 0; k &lt; dt.Columns.Count; k++) { object obj = dt.Rows[j][k]; Type type = obj.GetType(); if (type.Name == &quot;Int32&quot; || type.Name == &quot;Single&quot; || type.Name == &quot;Double&quot; || type.Name == &quot;Decimal&quot;) { double d = obj == DBNull.Value ? 0.0d : Convert.ToDouble(obj); if (type.Name == &quot;Int32&quot; || (d - Math.Truncate(d) == 0)) content.AppendFormat(&quot;&lt;td style=&apos;vnd.ms-excel.numberformat:#,##0&apos;&gt;{0}&lt;/td&gt;&quot;, obj); else content.AppendFormat(&quot;&lt;td style=&apos;vnd.ms-excel.numberformat:#,##0.00&apos;&gt;{0}&lt;/td&gt;&quot;, obj); } else content.AppendFormat(&quot;&lt;td style=&apos;vnd.ms-excel.numberformat:@&apos;&gt;{0}&lt;/td&gt;&quot;, obj); } content.Append(&quot;&lt;/tr&gt;\\n&quot;); } content.Append(&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;); content.Replace(&quot;&amp;nbsp;&quot;, &quot;&quot;); using (var w = new StreamWriter(savePath, false, Encoding.UTF8)) { w.WriteLine(content); } return savePath; } } 4. 使用Ini文件保存输入public class IniHelper { // 声明INI文件的写操作函数 WritePrivateProfileString() [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern long WritePrivateProfileString(string section, string key, string val, string filePath); // 声明INI文件的读操作函数 GetPrivateProfileString() [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern int GetPrivateProfileString(string section, string key, string def, System.Text.StringBuilder retVal, int size, string filePath); private int retLength = 500; private string sPath = null; public IniHelper(string path, int rl = 500) { this.sPath = path; if (rl &gt; 0) { this.retLength = rl; } } public void WriteValue(string key, string value, string section = &quot;Setting&quot;) { // section=配置节，key=键名，value=键值，path=路径 WritePrivateProfileString(section, key, value, sPath); } public string ReadValue(string key, string section = &quot;Setting&quot;) { // 每次从ini中读取多少字节 System.Text.StringBuilder temp = new System.Text.StringBuilder(retLength); // section=配置节，key=键名，temp=上面，path=路径 GetPrivateProfileString(section, key, &quot;&quot;, temp, retLength, sPath); return temp.ToString(); } } 5. 文本框全选功能public frmMain() { this.ControlAdded += new System.Windows.Forms.ControlEventHandler(this.Control_ControlAdded); //注册全选功能 InitializeComponent(); } #region 文本框能够使用Ctrl+A 全选功能 private void Control_ControlAdded(object sender, ControlEventArgs e) { //使“未来”生效 e.Control.ControlAdded += new System.Windows.Forms.ControlEventHandler(this.Control_ControlAdded); //使“子孙”生效 foreach (Control c in e.Control.Controls) { Control_ControlAdded(sender, new ControlEventArgs(c)); } //使“过去”生效 TextBox textBox = e.Control as TextBox; if (textBox != null) { textBox.KeyPress += TextBox_KeyPress; } } private void TextBox_KeyPress(object sender, KeyPressEventArgs e) { TextBox textBox = sender as TextBox; if (textBox == null) return; if (e.KeyChar == (char)1) { textBox.SelectAll(); e.Handled = true; } } #endregion 6. 打开保存的excelprivate void btnOpenDir_Click(object sender, EventArgs e) { var txtFileName = this.txtFileName.Text; var txtExportDir = this.txtExportDir.Text; var openPath = Path.Combine(txtExportDir, txtFileName); if (File.Exists(openPath)) { System.Diagnostics.Process.Start(openPath, &quot;c:\\\\windows&quot;); } else { AppendTipMsg(&quot;文件&quot; + openPath + &quot;不存在&quot;); } } 7. 页面主要功能代码 winform中使用多线程时给ui控件赋值var txtThread = new Thread(() =&gt; txtMsg.BeginInvoke(new Action(() =&gt; txtMsg.AppendText(&quot;向文本框中追加内容&quot;)))); txtThread.Start(); 8. 一些记录winform中使用多线程时给ui控件赋值var txtThread = new Thread(() =&gt; txtMsg.BeginInvoke(new Action(() =&gt; txtMsg.AppendText(&quot;向文本框中追加内容&quot;)))); txtThread.Start(); 源码中的NopI组件可移除，此工具实际未用到 开启线程执行导出的时候使用的是Task.Run(() =&gt;{});若将框架版本改为4.0则需要将此处修改为new Thread(() =&gt;{}).Start(); 整个过程解决了一下问题 数据库查询（SqlSugar支持sqlserver,mysql） datatable转excel文本 ini存取文件 winform文本框全选功能 winform中使用多线程时给ui控件赋值 源码 下载使用：http://files.cnblogs.com/files/morang/DB数据导出工具.rar源码下载：http://files.cnblogs.com/files/morang/DB数据导出工具_源码.rarCoding地址：https://coding.net/u/yimocoding/p/WeDemo/git/tree/NopiExcelDemogit克隆：git clone https://git.coding.net/yimocoding/WeDemo.git -b NopiExcelDemo 使用说明"},{"title":"使用批处理脚本愉快的清理缓存","permalink":"https://yimogit.github.io/2017/06/03/使用批处理脚本愉快的清理缓存/","text":"站点缓存着实头痛，那么~重启吧 网站做了站点缓存，测试的时候修改数据后需要重启站点来清楚缓存如何无需登陆服务器又不用改代码就可以清理换网站上的缓存呢？用重启iis怎么样~能重启IIS，自然也能干其他的 实现步骤 连接到远程主机 在远程主机一个创建一个包含iisreset命令(+移除计划任务)的脚本 给远程主机添加一项过期的计划任务 立即执行计划任务 完整批处理脚本- 重启iis.bat1234567891011121314151617181920212223242526272829303132333435@echo offREM 远程地址set ycip=192.168.1.123REM 服务器登陆名set ycname=AdministratorREM 服务器登陆密码set ycpwd=123456REM 计划任务名称set planName=自动重启IISREM ipc名称set ipcName=adminREM 执行脚本地址 \\\\%ycip%\\%ipcName%$\\ 对应C:\\Windowsset execbat=\\\\%ycip%\\%ipcName%$\\Temp\\execiisresest.batREM 执行路径set taskPath=C:\\Windows\\Temp\\execiisresest.batecho 建立远程连接net use \\\\%ycip%\\%ipcName%$ \"%ycpwd%\" /user:%ycname%echo 写入脚本到远程脚本REM ....写日志 未写入可能是权限问题echo echo %time%执行任务^&gt;^&gt;C:^\\Windows^\\Temp^\\iisreset_log.txt&gt;%execbat%REM ....重启IISecho iisreset&gt;&gt;%execbat%REM ....删除计划任务 echo yes| 始终确认echo echo yes^| SCHTASKS /Delete /TN \"%planName%\" /F&gt;&gt;%execbat%REM 任务时间 设置一个过期时间，但是立即执行set tasktime=\"00:00\"echo 在远程主机创建计划任务SCHTASKS /Create /S %ycip% /U %ycip%\\%ycname% /P \"%ycpwd%\" /SC ONCE /ST %tasktime% /TN %planName% /TR %taskPath% /RU %ycname%echo 立即执行定义的计划任务SCHTASKS /Run /S %ycip% /U %ycip%\\%ycname% /P \"%ycpwd%\" /I /TN \"%planName%\"REM 删除IPC连接net use \\\\%ycip%\\%ipcName%$ /delpause 关于脚本中的几个关键点 批处理脚本中如何定义变量？ 定义：set 变量名=值 使用：%变量名% 计算：set /a v1=1+1 –&gt;v1==2 set v2=1+1–&gt;v2==”1+1” 如何写入文件？ 写入：echo 我是文本&gt;文件名.后缀名 追加写入：echo 我是文本&gt;&gt;文件名.后缀名 追加一个换行符：echo. &gt;&gt;文件名.后缀名 自动确认yes：echo yes| 如何写入文件到建立远程连接首先建立远程连接： net use \\\\192.168.1.123\\admin$ &quot;密码&quot; /user:登陆名 路径对应C:\\Windows写入文件：echo 文本&gt;\\\\192.168.1.123\\admin$\\文件路径 在远程主机创建计划任务并执行 创建计划任务：SCHTASKS /Create /S %主机地址% /U %主机地址%\\%主机登陆名% /P &quot;%密码%&quot; /SC ONCE /ST %计划任务名% /TN %计划任务名% /TR %脚本或程序地址% /RU %主机登录名亦可% 立即执行：SCHTASKS /Run /S %主机地址% /U %主机地址%\\%主机登陆名% /P &quot;%密码%&quot; /I /TN &quot;%计划任务名%&quot; 删除任务：SCHTASKS /Run /S %主机地址% /U %主机地址%\\%主机登陆名% /P &quot;%密码%&quot; /I /TN &quot;%计划任务名%&quot; 如何将 |,&gt; 等特殊字符写入文本 示例：echo ^|&gt;xxx.txt ^为转义字符，这样就能特殊字符输出或写入文件了 5种if语句的基本语法： 判断两个字符串是否相等，if &quot;字符串1&quot;==&quot;字符串2&quot;(command语句) else () 判断两个数值是否相等，if 数值1 equ 数值2 command语句 判断判断驱动器，文件或文件夹是否存在if exist filename command语句 判断变量是否已经定义，if defined 变量 command语句 判断上个命令的返回值，if errorlevel 数值 command语句 计划任务是会在C:\\Windows\\system32目录下执行的，所以若脚本中未重定向路径，则日志会保存到system32目录 参考文章利用schtasks远程执行命令 https://sanwen.net/a/rsjveqo.htmlDOS批处理中的特殊符号 http://www.2cto.com/os/201309/241025.htmlDOS批处理添加任务计划 http://www.echojb.com/computer/2017/04/26/363341.html"},{"title":"如何生成ssh公钥","permalink":"https://yimogit.github.io/2017/05/28/如何生成ssh公钥/","text":"windows下生成ssh_key会生成id_rsa以及 id_rsa.pub。输入命令三次回车即可sshkey生成到id_rsa.pub中，将文件中的公钥复制到coding或者GitHub即可生成命令：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;生成目录：C:\\Users\\用户名\\.ssh （Linux下/your_home_path/.ssh/id_rsa） 详细：http://www.jianshu.com/p/31cbbbc5f9fa/"},{"title":"Git常用命令记录","permalink":"https://yimogit.github.io/2017/05/21/git常用命令记录/","text":"配置本地仓库 设置用户名：git config --global user.name 易墨 设置邮箱：git config --global user.email yimo@yimo.com 删除配置： git config --global --unset key 更多 查看配置详情 git config -l 初始仓库 git init git init --bare –初始化一个共享仓库 查看当前仓库的状态 git status 添加文件到暂存区 git add * –添加当前目录下的所有未排除的文件,或使用git add --all git add -u –仅监控已经被add的文件或git add --update git add . –提交不包括被删除的文件的修改 提交到本地仓库 git commit -m 备注信息 撤销修改 git checkout . –撤销本地所有修改 git checkout 路径/*.cs–撤销本地路径下的所有cs文件 git revert –将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容 git revert HEAD –撤销前一次commit git revert HEAD^ –撤销前前一次commit git revert commitid –撤销指定版本 git reset 撤销暂存 git reset HEAD &lt;file&gt; –撤销已经被暂存的文件 查看本地仓库的提交历史 git log 克隆仓库 git clone 仓库地址 –克隆远程仓库的默认分支，可以是本地文件路径，也可以是远程地址 git clone https://github.com/../xxx.git -b 分支名称 –克隆远程仓库的指定分支 git clone https://github.com/../xxx.git 文件夹路径 –克隆远程仓库到指定文件夹 分支操作 命令中的origin为默认的主机别名 本地操作 git branch –查看本地分支 git branch -a –查看本地及远程分支 git branch 分支名称 –在本地创建一个新分支 git checkout 分支名称 –获取远程分支并切换到该分支 git checkout -b 分支名称 –获取远程分支,不存在则创建，并切换到该分支 git branch -d 分支名称 –删除本地分支 git branch -m 分支名称 新分支名称 –分支重命名 更新远程分支 git fetch – 更新本地仓库的所有分支，不合并到分支(通常用来查看其他人的进程) git fetch orgin 分支名称 – 更新本地仓库的指定分支，不合并到分支(通常用来查看其他人的进程) git pull –更新当前分支 git pull origin 远程分支:本地分支 –取回origin主机的远程分支，与指定本地分支合并 删除远程分支 git push origin --delete 分支名称 –v1.7.0+ git push origin :分支名称 –删除远程分支,例：git push origin :gh-pages，意为将空白分支变成远程分支 重命名远程分支 git push --delete origin 远程分支 – 删除本地远程分支（github上需为非默认分支） git branch -m 本地分支 新远程分支名 –重命名分支 git push orgin 新远程分支名 –推送本地分支 合并操作 git merge -b 分支名称 –合并当前分支到指定分支 推送 如果本地仓库分支名称==远程仓库分支名称,可直接使用 git push git push origin 本地分支名称:远程分支名称 –将本地分支推送至远程分支,远程分支不存在则自动创建 git remote add 主机别名 远程仓库地址 –添加远程主机，给远程主机起个别名，方便使用,默认的为origin git remote –查看已添加的远程主机 git remote show 主机别名 可以查看远程主机的信息 总结一下，收获满满。"},{"title":"使用bat脚本部署hexo到coding和github","permalink":"https://yimogit.github.io/2017/05/20/使用bat脚本部署hexo到coding和github/","text":"因项目的不同适当的改造吧，本文以hexo为例。 拉取coding.net的代码和github的代码到本地 确保代码能够正常的运行，commit,push 在项目的目录外新建一个push.bat文件 快速预览 如何一步到位提交到仓库 脚本中的变量说明 artsPath 新增文章的目录 codingPath coding的目录 githubPath github的目录 复制文章然后自动执行命令进行部署 修改脚本中对应的路径后执行push 12345678xcopy F:\\CodingRepos\\ymhexo\\arts F:\\CodingRepos\\ymhexo\\yimocoding\\source\\_posts /Ycd F:\\CodingRepos\\ymhexo\\yimocodingcall git pullcall hexo cleancall hexo d -gcall git add *call git commit -m AddArticlecall git push 优化v1-加入变量并读取第一个参数为注释 查阅了果然cmd是有变量的，所以提前了路径到变量中，注释也可以传入了使用push 修改文章,提交之后注释为update_修改文章，可省略参数 123456789101112set artsPath=F:\\CodingRepos\\ymhexo\\artsset codingPath=F:\\CodingRepos\\ymhexo\\yimocodingset githubPath=F:\\CodingRepos\\ymhexo\\yimogit.github.ioxcopy %artsPath% %codingPath%\\source\\_posts /Ycd /d %codingPath%call git pullcall hexo cleancall hexo d -gcall git add *call git commit -m update_%1call git push 优化v2-多个仓库的部署 复制粘贴是最简单的了，but~ 我感觉还能再优化下定义变量，然后保存到字符串str中，通过赋值str后调整到for取下一个值实现一个路径的先入先出的T_T【笑哭】可以算作循环数组的方法了 123456789101112131415161718192021222324252627282930@echo offset artsPath=F:\\CodingRepos\\ymhexo\\artsREM coding的目录set codingPath=F:\\CodingRepos\\ymhexo\\yimocodingREM github的目录set githubPath=F:\\CodingRepos\\ymhexo\\yimogit.github.ioREM 默认注释add_article，第一个参数为注释set notes=%1 if \"%1\"==\"\" set notes=add_articleREM 拼接coding和github的目录地址，路径中不能含有空格set str=\"%codingPath% %githubPath%\":STR_STARTfor /f \"tokens=1,*\" %%a in (%str%) do ( REM 复制文章到此仓库 xcopy %artsPath% %%a\\source\\_posts\\ /Y REM 重定向到此仓库 cd /d %%a REM 更新推送等操作 call git pull call hexo clean call hexo d -g call git add * call git commit -m %notes% call git push REM 重新将新字符串赋值个str，并重新开时循环新的字符串 set str=\"%%b\" goto STR_START) 不愿干重复的事情~程序猿就是如此的懒~能一个脚本干完所有事简直完美~不知道有没有比这种方法更好的实现"},{"title":"windows下使用bat脚本部署hexo到coding和github","permalink":"https://yimogit.github.io/2017/05/20/windows下使用bat脚本部署hexo到coding和github/","text":"拉取coding.net的代码和github的代码到本地确保代码能够正常的运行，commit,push新建一个push.bat文件然后copy下面的代码再改改路径，将文章放到arts目录后运行push即可 artsPath 新增文章的目录 codingPath coding的目录 githubPath github的目录 如何一步到位提交到仓库复制文章然后自动执行命令进行部署 修改脚本中对应的路径后执行push 12345678xcopy F:\\CodingRepos\\ymhexo\\arts F:\\CodingRepos\\ymhexo\\yimocoding\\source\\_posts /Ycd F:\\CodingRepos\\ymhexo\\yimocodingcall git pullcall hexo cleancall hexo d -gcall git add *call git commit -m AddArticlecall git push 优化-加入变量并读取第一个参数为注释 查阅了果然cmd是有变量的，所以提前了路径到变量中，注释也可以传入了使用push 修改文章,提交之后注释为update_修改文章，可省略参数 123456789101112set artsPath=F:\\CodingRepos\\ymhexo\\artsset codingPath=F:\\CodingRepos\\ymhexo\\yimocodingset githubPath=F:\\CodingRepos\\ymhexo\\yimogit.github.ioxcopy %artsPath% %codingPath%\\source\\_posts /Ycd /d %codingPath%call git pullcall hexo cleancall hexo d -gcall git add *call git commit -m update_%1call git push 多个仓库的部署 复制粘贴是最简单的了，but~我猜肯定有for循环可以用 123456789101112131415161718@echo offset artsPath=F:\\CodingRepos\\ymhexo\\artsset gitPaths=\"F:\\CodingRepos\\ymhexo\\yimocoding F:\\CodingRepos\\ymhexo\\yimogit.github.io\":GIT_VISTORfor /f \"tokens=1,*\" %%a in (%str%) do ( xcopy %artsPath% %%a\\source\\_posts /Y cd /d %%a call git pull call hexo clean call hexo d -g call git add * call git commit -m update_%1 call git push REM 将剩余字符串赋值给str变量 set str=\"%%b\" goto GIT_VISTOR) 如果要自己填写注释可以将 AddArticle 换成%1 来获取第一个参数"},{"title":"初次尝试Linux并记录一二","permalink":"https://yimogit.github.io/2017/05/19/初次尝试Linux并记录一二/","text":"假如我有一个Linux系统安装过程：加载中…版本：Ubuntu Server 16.04.1 LTS 64位得到一个IP：... 下载工具 WinSCP: WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端PuTTY: PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件网盘下载 设置winscp集成终端Putty 新建会话 连接Putty 安装一个软件然后学习一堆命令 ubuntu安装软件可参考：http://www.cnblogs.com/xwdreamer/p/3623454.html 安装一个tree来查看目录树sudo apt-get install tree：意作以管理员身份使用apt-get安装tree程序 命令示例 文件操作的一些命令 更多总结：http://www.cnblogs.com/chenhaoyu/p/6668571.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏文件touch 创建空文件 创建示例：touch hello.txt echo 写入字符到文件 打印示例：echo 'hello world' 写入示例: echo \"hello\"&gt;hello.txt 追加示例: echo \"hello233\"&gt;&gt;hello.txt 更多技巧：http://blog.csdn.net/xukai871105/article/details/35834703 cat 查看文件内容 查看示例：cat hello.txt wc 统计文本中行数，字数，字符数 cp 复制文件 复制示例：cp hello.txt hello2.txt mv 移动或重命名 移动示例：mv hello2.txt hello3.txt #移动到同一个目录==重命名 rm 删除文件 -r 递归删除 -f 强制删除 删除文件示例：rm hello3.txt 删除目录示例：rm ./testdir -r mkdir 创建目录 -p 创建上层目录，如目录早已存在则不当作错误 创建示例： mkdir testdir/a #testdir存在 创建示例2： mkdir testdir2/test/ -p #testdir2不存在 cd 切换目录rmdir 删除空目录 删除示例：rmdir testdir #非空目录使用rm testdir -r pwd 显示当前目录 find 在文件系统中搜索某文件 查找示例：find testdir *.txt #查找testdir下所有txt文件 更多技巧：http://www.cnblogs.com/wanqieddy/archive/2011/06/09/2076785.html grep 在文本文件中查找字符串 查找示例：grep 'he' ./hello.txt 更多技巧：http://www.cnblogs.com/end/archive/2012/02/21/2360965.html tree 安装后使用tree命令以树节点查看目录文件 nano 一个文本编辑器 使用示例：nano hello.txt 编辑完成Ctrl+X，y，回车~~ apt-get和dpkg的一些命令 更多详情见：http://www.cnblogs.com/forward/archive/2012/01/10/2318483.html 1234567891011121314151617181920212223242526272829303132333435apt-cache search # ------(package 搜索包)apt-cache show #------(package 获取包的相关信息，如说明、大小、版本等)apt-get install # ------(package 安装包)apt-get install # -----(package --reinstall 重新安装包)apt-get -f install # -----(强制安装, \"-f = --fix-missing\"当是修复安装吧...)apt-get remove #-----(package 删除包)apt-get remove --purge # ------(package 删除包，包括删除配置文件等)apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)apt-get update #------更新源apt-get upgrade #------更新已安装的包apt-get dist-upgrade # ---------升级系统apt-get dselect-upgrade #------使用 dselect 升级apt-cache depends #-------(package 了解使用依赖)apt-cache rdepends # ------(package 了解某个具体的依赖,当是查看该包被哪些包依赖吧...)apt-get build-dep # ------(package 安装相关的编译环境)apt-get source #------(package 下载该包的源代码)apt-get clean &amp;&amp; apt-get autoclean # --------清理下载文件的存档 &amp;&amp; 只清理过时的包apt-get check #-------检查是否有损坏的依赖dpkg -S filename -----查找filename属于哪个软件包apt-file search filename -----查找filename属于哪个软件包apt-file list packagename -----列出软件包的内容apt-file update --更新apt-file的数据库dpkg --info \"软件包名\" --列出软件包解包后的包名称.dpkg -l --列出当前系统中所有的包.可以和参数less一起使用在分屏查看. (类似于rpm -qa)dpkg -l |grep -i \"软件包名\" --查看系统中与\"软件包名\"相关联的包.dpkg -s 查询已安装的包的详细信息.dpkg -L 查询系统中已安装的软件包所安装的位置. (类似于rpm -ql)dpkg -S 查询系统中某个文件属于哪个软件包. (类似于rpm -qf)dpkg -I 查询deb包的详细信息,在一个软件包下载到本地之后看看用不用安装(看一下呗).dpkg -i 手动安装软件包(这个命令并不能解决软件包之前的依赖性问题),如果在安装某一个软件包的时候遇到了软件依赖的问题,可以用apt-get -f install在解决信赖性这个问题.dpkg -r 卸载软件包.不是完全的卸载,它的配置文件还存在.dpkg -P 全部卸载(但是还是不能解决软件包的依赖性的问题)dpkg -reconfigure 重新配置 搭建一个nodejs环境 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install stable #安装最新稳定版 nano hello.js 新建一个文件;注：nano,vi都是Linux自带的文本编辑器，我选择了nano，不要问我为什么~输入完成后 Ctrl+x保存，输入y,然后回车就可退出，若想查看hello.js: cat hello.js //粘贴下面的代码到编辑器（复制后单右键） var http = require('http'); http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World233\\n'); }).listen(2323, '0.0.0.0');//这里需要监听0.0.0.0,使其能在外网访问到 console.log('服务启动：http://ip:2323/'); 现在就可以在本地访问http://服务器ip:2323/看到输出了 激活root用户 root用户是系统中唯一的超级管理员，它具有等同于操作系统的权限 第一次激活需要设置root用户的密码，如果出现su: Authentication failure就需要重置密码 设置root密码：sudo passwdPassword:就输入你当前的用户密码Enter new UNIX password：root的新密码Retype new UNIX password：重复设置的新密码 切换用户 切换到root用户：su root切换到ubuntu:su ubuntu 最后，园子虐我千万遍，我待园子如初恋~"},{"title":"js实用方法记录-指不定哪天就会用到的js方法","permalink":"https://yimogit.github.io/2017/05/19/js实用方法记录-指不定哪天就会用到的js方法/","text":"js实用方法记录-指不定哪天就会用到的js方法 常用或者不常用都有 判断是否在微信浏览器中 测试代码：isWeiXin()==false 1234567891011/** * 是否在微信中 */function isWeixin() &#123; var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == \"micromessenger\") &#123; return true; &#125; else &#123; return false; &#125;&#125; 全角转半角 测试代码：wholetoHalf(&#39;ｈｅｌｌｏ&#39;&#39;)==&#39;hello&#39; 12345678910111213141516171819202122/** * 转换全角字符串 * @param &#123;string&#125; txt 含全角字符串 */function wholetoHalf(txt)&#123; if (!txt) &#123; return txt; &#125; var tmp = \"\"; for (var i = 0; i &lt; txt.length; i++) &#123; if (txt.charCodeAt(i) &gt; 65280 &amp;&amp; txt.charCodeAt(i) &lt; 65375) &#123; tmp += String.fromCharCode(txt.charCodeAt(i) - 65248); &#125; else if (txt.charCodeAt(i) == 12288) &#123; tmp += String.fromCharCode(32); &#125; else &#123; tmp += String.fromCharCode(txt.charCodeAt(i)); &#125; &#125; return tmp;&#125; 生成Guid12345678910/** * 生成Guid */function genGuid() &#123; function S4() &#123; return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1); &#125; return (S4() + S4() + \"-\" + S4() + \"-4\" + S4().substr(0, 3) + \"-\" + S4() + \"-\" + S4() + S4() + S4()).toLowerCase();&#125; 获取滚动条距顶部距离1234567891011121314/** * 获取滚动条距顶部距离 */function getScrollTop() &#123; var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0; if (document.body) &#123; bodyScrollTop = document.body.scrollTop; &#125; if (document.documentElement) &#123; documentScrollTop = document.documentElement.scrollTop; &#125; scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop; return scrollTop;&#125; 获取滚动条高度1234567891011121314/** * 获取滚动条高度 默认 */function getScrollHeight() &#123; var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0; if (document.body) &#123; bodyScrollHeight = document.body.scrollHeight; &#125; if (document.documentElement) &#123; documentScrollHeight = document.documentElement.scrollHeight; &#125; scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; 0) ? bodyScrollHeight : documentScrollHeight; return scrollHeight;&#125; 通过判断滚动条位置操作元素1234if(getScrollHeight() &gt; document.documentElement.clientHeight &amp;&amp; getScrollTop()&gt;getScrollHeight()/4)&#123;//有滚动条且滚动条距离顶部在四分之外 //显示回到顶部浮层什么的~~&#125; 编码HTML UBB：HTML代码的安全代码 12345678910111213141516171819202122232425262728293031/** * 转换HTML字符串为UBB字符串 */function toUbb(str)&#123; str = str.replace(/&lt;/ig,'&amp;lt;'); str = str.replace(/&gt;/ig,'&amp;gt;'); str = str.replace(/\\n/ig,'&lt;br /&gt;'); str = str.replace(/\\[code\\](.+?)\\[\\/code\\]/ig, function($1, $2) &#123;return phpcode($2);&#125;); str = str.replace(/\\[hr\\]/ig,'&lt;hr /&gt;'); str = str.replace(/\\[\\/(size|color|font|backcolor)\\]/ig,'&lt;/font&gt;'); str = str.replace(/\\[(sub|sup|u|i|strike|b|blockquote|li)\\]/ig,'&lt;$1&gt;'); str = str.replace(/\\[\\/(sub|sup|u|i|strike|b|blockquote|li)\\]/ig,'&lt;/$1&gt;'); str = str.replace(/\\[\\/align\\]/ig,'&lt;/p&gt;'); str = str.replace(/\\[(\\/)?h([1-6])\\]/ig,'&lt;$1h$2&gt;'); str = str.replace(/\\[align=(left|center|right|justify)\\]/ig,'&lt;p align=\"$1\"&gt;'); str = str.replace(/\\[size=(\\d+?)\\]/ig,'&lt;font size=\"$1\"&gt;'); str = str.replace(/\\[color=([^\\[\\&lt;]+?)\\]/ig, '&lt;font color=\"$1\"&gt;'); str = str.replace(/\\[backcolor=([^\\[\\&lt;]+?)\\]/ig, '&lt;font style=\"background-color:$1\"&gt;'); str = str.replace(/\\[font=([^\\[\\&lt;]+?)\\]/ig, '&lt;font face=\"$1\"&gt;'); str = str.replace(/\\[list=(a|A|1)\\](.+?)\\[\\/list\\]/ig,'&lt;ol type=\"$1\"&gt;$2&lt;/ol&gt;'); str = str.replace(/\\[(\\/)?list\\]/ig,'&lt;$1ul&gt;'); str = str.replace(/\\[s:(\\d+)\\]/ig,function($1,$2)&#123; return smilepath($2);&#125;); str = str.replace(/\\[img\\]([^\\[]*)\\[\\/img\\]/ig,'&lt;img src=\"$1\" border=\"0\" /&gt;'); str = str.replace(/\\[url=([^\\]]+)\\]([^\\[]+)\\[\\/url\\]/ig, '&lt;a href=\"$1\"&gt;'+'$2'+'&lt;/a&gt;'); str = str.replace(/\\[url\\]([^\\[]+)\\[\\/url\\]/ig, '&lt;a href=\"$1\"&gt;'+'$1'+'&lt;/a&gt;'); return str; &#125; 解码ubb字符串1234567891011121314151617181920212223242526272829/** * 转换UBB字符串为HTML字符串 */function toHtml(str)&#123; //详情见：http://tool.oschina.net/ubb //str = str.replace(/(\\r\\n|\\n|\\r)/ig, ''); str = str.replace(/&lt;br[^&gt;]*&gt;/ig,'\\n'); str = str.replace(/&lt;p[^&gt;\\/]*\\/&gt;/ig,'\\n'); //str = str.replace(/\\[code\\](.+?)\\[\\/code\\]/ig, function($1, $2) &#123;return phpcode($2);&#125;); str = str.replace(/\\son[\\w]&#123;3,16&#125;\\s?=\\s*([\\'\\\"]).+?\\1/ig,''); str = str.replace(/&lt;hr[^&gt;]*&gt;/ig,'[hr]'); str = str.replace(/&lt;(sub|sup|u|strike|b|i|pre)&gt;/ig,'[$1]'); str = str.replace(/&lt;\\/(sub|sup|u|strike|b|i|pre)&gt;/ig,'[/$1]'); str = str.replace(/&lt;(\\/)?strong&gt;/ig,'[$1b]'); str = str.replace(/&lt;(\\/)?em&gt;/ig,'[$1i]'); str = str.replace(/&lt;(\\/)?blockquote([^&gt;]*)&gt;/ig,'[$1blockquote]'); str = str.replace(/&lt;img[^&gt;]*smile=\\\"(\\d+)\\\"[^&gt;]*&gt;/ig,'[s:$1]'); str = str.replace(/&lt;img[^&gt;]*src=[\\'\\\"\\s]*([^\\s\\'\\\"]+)[^&gt;]*&gt;/ig,'[img]'+'$1'+'[/img]'); str = str.replace(/&lt;a[^&gt;]*href=[\\'\\\"\\s]*([^\\s\\'\\\"]*)[^&gt;]*&gt;(.+?)&lt;\\/a&gt;/ig,'[url=$1]'+'$2'+'[/url]'); //str = str.replace(/&lt;h([1-6]+)([^&gt;]*)&gt;(.*?)&lt;\\/h\\1&gt;/ig,function($1,$2,$3,$4)&#123;return h($3,$4,$2);&#125;); str = str.replace(/&lt;[^&gt;]*?&gt;/ig, ''); str = str.replace(/&amp;amp;/ig, '&amp;'); str = str.replace(/&amp;lt;/ig, '&lt;'); str = str.replace(/&amp;gt;/ig, '&gt;'); return str;&#125;"},{"title":"js实用方法记录-简单cookie操作","permalink":"https://yimogit.github.io/2017/05/19/js实用方法记录-简单cookie操作/","text":"js实用方法记录-简单cookie操作 设置cookie：setCookie(名称,值,保存时间,保存域);获取cookie：setCookie(名称);移除cookie：setCookie(名称,值,-1,保存域); 设置cookie 测试代码：setCookie(&#39;test&#39;,&#39;hello&#39;) //保存session级的cookie到根域测试代码：setCookie(&#39;test&#39;,&#39;hello&#39;,30,false) //保存30天且保存到当前全域名 123456789101112131415161718/** * 设置cookie * @param &#123;string&#125; name cookie名称 * @param &#123;string&#125; value cookie值 * @param &#123;number&#125;[expiredays=null] 过期时间 默认session级别 &lt;=0移除cookie * @param &#123;bool&#125;[saveRoot=true] 保存的域 默认根域 */function setCookie(name, value, expiredays=null,saveRoot=false) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays) var cookie = name + \"=\" + value + ';path=/' + ((expiredays == null) ? \"\" : \";expires=\" + exdate.toGMTString()); if(saveRoot)&#123; //适用于一级，二级，本地域名 var domain =((location.host.match(/\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;/g) || location.hostname=='localhost')? location.hostname:('.' + (location.host.split('.')[2]!=undefined?(location.host.split('.')[1]+'.'+location.host.split('.')[2]):location.host))); cookie+=(';domain='+domain); &#125; document.cookie = cookie;&#125; 获取cookie 测试代码: getCookie(&#39;test&#39;)==&#39;hello&#39; 1234567891011/** * 获取cookie * @param &#123;string&#125; name cookie名称 */function getCookie(name) &#123; var arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\"); if (arr = document.cookie.match(reg)) return unescape(arr[2]); else return null;&#125;"},{"title":"js实用方法记录-动态加载css、js","permalink":"https://yimogit.github.io/2017/05/19/js实用方法记录-动态加载cssjs/","text":"js实用方法记录-动态加载css、js 附送一个加载iframe,h5打开app代码 1. 动态加载js文件到head标签并执行回调 方法调用：dynamicLoadJs(&#39;http://www.yimo.link/static/js/main.min.js&#39;,function(){alert(&#39;加载成功&#39;)}); 1234567891011121314151617181920/** * 动态加载JS * @param &#123;string&#125; url 脚本地址 * @param &#123;function&#125; callback 回调函数 */function dynamicLoadJs(url, callback) &#123; var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; if(typeof(callback)=='function')&#123; script.onload = script.onreadystatechange = function () &#123; if (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\")&#123; callback(); script.onload = script.onreadystatechange = null; &#125; &#125;; &#125; head.appendChild(script);&#125; 2. 动态加载css文件到head 方法调用： dynamicLoadCss(&#39;http://www.yimo.link/static/css/style.css&#39;) 123456789101112/** * 动态加载CSS * @param &#123;string&#125; url 样式地址 */function dynamicLoadCss(url) &#123; var head = document.getElementsByTagName('head')[0]; var link = document.createElement('link'); link.type='text/css'; link.rel = 'stylesheet'; link.href = url; head.appendChild(link);&#125; 3. 动态加载脚本文件 参考：http://www.cnblogs.com/yuanke/p/5039699.html 1234567891011121314151617181920/** * 动态加载css脚本 * @param &#123;string&#125; cssText css样式 */function loadStyleString(cssText) &#123; var style = document.createElement(\"style\"); style.type = \"text/css\"; try&#123; // firefox、safari、chrome和Opera style.appendChild(document.createTextNode(cssText)); &#125;catch(ex) &#123; // IE早期的浏览器 ,需要使用style元素的stylesheet属性的cssText属性 style.styleSheet.cssText = cssText; &#125; document.getElementsByTagName(\"head\")[0].appendChild(style);&#125;// 测试var css = \"body&#123;color:blue;&#125;\";loadStyleString(css); 1234567891011121314151617181920/** * 动态加载js脚本 * @param &#123;string&#125; code js脚本 */function loadScriptString(code) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; try&#123; // firefox、safari、chrome和Opera script.appendChild(document.createTextNode(code)); &#125;catch(ex) &#123; // IE早期的浏览器 ,需要使用script的text属性来指定javascript代码。 script.text = code; &#125; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;// 测试var text = \"function test()&#123;alert('test');&#125;\";loadScriptString(text);test(); 4. 动态加载iframe到body标签并执行回调 方法调用：dynamicLoadIframe(&#39;http://www.yimo.link&#39;,function(){alert(&#39;加载成功&#39;)},&#39;&#39;); 123456789101112131415161718192021/** * 动态加载Iframe * @param &#123;string&#125; url 脚本地址 * @param &#123;function&#125; callback 回调函数 * @param &#123;string&#125; style 加载样式 */function dynamicLoadIframe(url,callback,style) &#123; var body = document.getElementsByTagName('body')[0]; var iframe = document.createElement('iframe'); iframe.src = url; iframe.style=style||'display:none;width:0px;height:0px;'; if(typeof(callback)=='function')&#123; iframe.onload = iframe.onreadystatechange = function () &#123; if (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\") &#123; callback(); iframe.onload = iframe.onreadystatechange = null; &#125; &#125;; &#125; body.appendChild(iframe);&#125; 5. M站中下载/打开app方法测试：openApp(&#39;ios页面&#39;,&#39;**.apk&#39;,&#39;metools://home&#39;); 123456789101112131415161718192021222324252627282930313233function openApp(iosDownUrl,andDownUrl,appUrl) &#123; var ua = navigator.userAgent.toLowerCase(); if (/iphone|ipad|ipod/.test(ua)) &#123;//ios跳转到store window.location.href = iosDownUrl; return; &#125; if(ua.indexOf(\"micromessenger\") &gt; -1)&#123;//微信中不能打开其他app window.location.href = andDownUrl; return; &#125; if (/android/.test(ua)) &#123;//安卓手机尝试调用app if(!appUrl)&#123; console.log('未指定需要打开的App,可参考http://www.oschina.net/code/snippet_256033_35330/'); return; &#125; var su = appUrl;//\"metools://index\";//自定义协议 var n = setTimeout(function () &#123; window.location.href = andDownUrl &#125;, 500); var r = document.createElement(\"iframe\"); r.src = su; r.onload = function () &#123; console.log('iframe load') clearTimeout(n); r.parentNode.removeChild(r); window.location.href = su; &#125;; r.setAttribute(\"style\", \"display:none;\"); document.body.appendChild(r); return; &#125; window.location.href = andDownUrl; &#125;"},{"title":"使用node自动生成html并调用cmd命令提交代码到仓库","permalink":"https://yimogit.github.io/2017/05/06/使用node自动生成html并调用cmd命令提交代码到仓库/","text":"生成html提交到git仓库 基于目前的express博客,写了一点代码,通过request模块来请求站点，将html保存到coding-pages目录，复制静态文件夹到coding-pages,最后使用node的child_process模块执行cmd命令提交到仓库~~ 1. 发送http请求 var request = require(&apos;request&apos;); var options = { url: url, encoding: null, headers: { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36&apos; } }; request(options, function (error, response, body) { //请求的回调，编码问题使用iconv模块解决 //var iconv = require(&apos;iconv-lite&apos;); //var html=iconv.decode(body,&apos;utf-8&apos;); //若是需要解析html则可以使用cheerio模块 //var cheerio=require(&apos;cheerio&apos;).load(html,{decodeEntities: false}); //然后就可以像jqueryy一样去解析html了。 //cheerio(&apos;选择器&apos;); }); 然后就可以愉快的抓数据了。之前也写过基于request，iconv，cheerio,schedule(定时调度模块)写了一个抓取的框架 保存html到目录 得到url的路径部分(除去域名)，即：/index.html,/msg.html…现在只需要根据这个路径和获取到的html保存即可此时有了保存的路径和内容，保存还不小事一桩么。如下。 function writeText(pathName,content){ var dir= pathHelper.dirname(pathName);//获取到路径中的目录 fs.exists(dir, function (exists) {//如果不存在则创建目录 if(exists==false){ fs.mkdir(dir); } }); fs.writeFile(pathName, content, function (err) {//写入内容 if (err){ console.log(pathName+&apos;生成失败&apos;); } }); } 使用node执行.bat文件复制静态文件到coding-pages目录 复制目录可以使用async模块实现的目录操作调用copyDir方法即可。也可以使用child_process模块来调用cmd命令实现 注：直接使用require(‘child_process’).exec 执行xcopy并不能复制目录，需要一种折中的方式如下： var exec = require(&apos;child_process&apos;).exec; var execbat = __dirname + &apos;\\\\exec.bat&apos;; //1. 创建复制脚本 commonHelper.writeText(execbat, &apos;xcopy F:\\\\CodingRepos\\\\yimocoding\\\\coding-pages\\\\tag F:\\\\CodingRepos\\\\yimocoding\\\\coding-pages\\\\tag3 /s /e /Q /Y /I&apos;); //2.执行批处理复制目录 exec(execbat, function (err, stdout, stderr) { if (err) { console.log(err); } else{ console.log(&apos;复制成功&apos;); } }); //3.删除批处理文件 exec(&apos;del &apos; + execbat, function (err, stdout, stderr) { if (err) { console.log(err); }else{ console.log(&apos;删除脚本成功&apos;); } }) 啥？怎么提交到git 运行环境安装好。能从cmd命令提交(配置环境变量)然后，看代码呗~~ var cmds = [ &apos;git add *&apos;, &apos;git commit -m &quot;提交。。。&quot;&apos;, &apos;git push&apos; ] cmds.forEach(function (cmd, i) { setTimeout(function () { console.log(cmd); exec(cmd, function (err, stdout, stderr) { if (err) { console.log(err); } }); }, i * 1000); }) 写文章还是挺累的。但是把用到的东西记录下来是有必要的。文笔欠佳，然记录一二也是挺好滴。"},{"title":"express使用记录","permalink":"https://yimogit.github.io/2017/05/06/express使用记录/","text":"随便记录下系列 - node-&gt;express 文章用啥写？→→ VsCode。代码用啥写？→→ VsCode。编辑器下载：VsCode 一、windows下安装node.js环境： 下载地址 相比以前搭过的服务端语言的环境,node环境的安装简直是业界良心即使第一次折腾了2天，第二次折腾了2小时，第三次折腾了2分钟 下载其他版本只需要替换下载链接 https://nodejs.org/dist/v6.2.0/node-v6.2.0-x64.msi 的2个版本号6.2.0为你需要的版本即可 尽量别把node安装在C盘(使用D:\\Program Files\\nodejs) 基础配置项(根据需要设置环境变量) 设置全局安装包路径： npm config set prefix &quot;D:\\Program Files\\nodejs\\node_global 设置缓存目录： npm config set cache &quot;D:\\Program Files\\nodejs\\node_cache 设置淘宝镜像源： npm install -g cnpm --registry=https://registry.npm.taobao.org PS： vue2.0用node-v4.5吧~，npm升级命令npm update 升级npm版本,若是不行则切换为32位版本的试试,再不行换个系统试试T-_-T 二、使用express 安装express 中文网 看文档！！！ 有网,有 node ,有 npm/cnpm/… 全局安装express： npm install express -g 安装express应用生成器： npm install express-generator -g 创建一个express(v4.14.0)应用： express mydemo 启动应用： npm start 自动更新修改 supervisor 运行起express应用,并做了一丁点修改后，习惯性保存后去刷新了页面，卧槽，【假装这是一张表情图】，左思右想百思不得其解~~~于是百度 “express 自动刷新“,你以为出来了么？并没有~那就换个词试试：”express 修改更新“,遂知supervisor~ 安装：npm install supervisor -g 启动express：supervisor ./bin/www 名字太长了~，改package.json-&gt;scripts-&gt;start配置啊：{&quot;start&quot;: &quot;supervisor ./bin/www&quot;} 在正确的目录使用正确的姿势执行npm start 修改模板引擎为jshtml 若要问我为什么，我只能说看着爽,即使jshtml最后一次更新在n年前~ 安装jshtml-express到项目：npm install jshtml-express --save 在app.js设置模板引擎为jsthml app.engine(&#39;jshtml&#39;, require(&#39;jshtml-express&#39;)); app.set(&#39;view engine&#39;, &#39;jshtml&#39;); 视图文件修改后缀名为.jshtml(.jshtml没高亮？把后缀改成cshtml写代码,然后修改vscode文件关联项：files.associations为{&quot;*.jshtml&quot;:&quot;cshtml&quot;}) 然后就去瞅文档吧。哈哈 路由中输出模型的时候需要用res.locals = model;输出模型，视图中使用@locals表示为模型 博客已使用express+jshtml：https://coding.net/u/yimocoding/p/yimocoding/git/tree/server/ 博客园主页：cnblogs.comCoding主页：coding.net"},{"title":"iis发布后模板字体不能加载的解决方案","permalink":"https://yimogit.github.io/2017/05/06/iis发布后模板字体不能加载的解决方案/","text":"在使用ace模板的过程中就曾遇到过图标不显示的情况，1、在iis和vs运行都不能显示图标，添加缺失的字体库后可以访问 2、把项目签入到阿里云时再一次失效，解决方法是添加Mime类型 .woff application/x-font-woff .woff2 application/x-font-woff .svg image/svg+xml 3、在使用H+模板的时候又出现了问题，然后前两种都没能解决问题，因为mvc的原因， 需要在webconfig中的system.webServer节点添加配置 代码如下 12345678910111213141516&lt;system.webServer&gt; &lt;staticContent&gt; &lt;remove fileExtension=&quot;.woff&quot;/&gt; &lt;mimeMap fileExtension=&quot;.woff&quot; mimeType=&quot;application/x-font-woff&quot; /&gt; &lt;remove fileExtension=&quot;.woff2&quot;/&gt; &lt;mimeMap fileExtension=&quot;.woff2&quot; mimeType=&quot;application/x-font-woff2&quot; /&gt; &lt;remove fileExtension=&quot;.ttf&quot; /&gt; &lt;mimeMap fileExtension=&quot;.ttf&quot; mimeType=&quot;application/x-font-truetype&quot; /&gt; &lt;remove fileExtension=&quot;.svg&quot; /&gt; &lt;mimeMap fileExtension=&quot;.svg&quot; mimeType=&quot;image/svg+xml&quot; /&gt; &lt;remove fileExtension=&quot;.otf&quot; /&gt; &lt;mimeMap fileExtension=&quot;.otf&quot; mimeType=&quot;application/x-font-opentype&quot; /&gt; &lt;remove fileExtension=&quot;.eot&quot; /&gt; &lt;mimeMap fileExtension=&quot;.eot&quot; mimeType=&quot;application/vnd.ms-fontobject&quot; /&gt; &lt;/staticContent&gt;&lt;/system.webServer&gt; –仅以记录开发中所遇问题。"},{"title":"C#使用NOPI导入Excel","permalink":"https://yimogit.github.io/2017/05/03/Csharp使用NOPI导入Excel/","text":"使用NOPI导入Excel文档 NOPI版本：2.3.0,依赖于NPOI的SharpZipLib版本：0.86,经测试适用于.net4.0+ 记录遇到的几个问题 NOPI中的IWorkbook接口：xls使用HSSFWorkbook类实现，xlsx使用XSSFWorkbook类实现 日期转换，判断row.GetCell(j).CellType == NPOI.SS.UserModel.CellType.Numeric &amp;&amp; HSSFDateUtil.IsCellDateFormatted(row.GetCell(j)不能直接使用row.GetCell(j).DateCellValue,这玩意会直接抛出异常来~ 1. 将文件流转换为DataTable/// &lt;summary&gt; /// 根据Excel格式读取Excel /// &lt;/summary&gt; /// &lt;param name=&quot;stream&quot;&gt;文件流&lt;/param&gt; /// &lt;param name=&quot;type&quot;&gt;Excel格式枚举类型，xls/xlsx&lt;/param&gt; /// &lt;param name=&quot;sheetName&quot;&gt;表名，默认取第一张&lt;/param&gt; /// &lt;returns&gt;DataTable&lt;/returns&gt; private static DataTable ImportExcel(Stream stream, ExcelExtType type, string sheetName) { DataTable dt = new DataTable(); IWorkbook workbook; try { //xls使用HSSFWorkbook类实现，xlsx使用XSSFWorkbook类实现 switch (type) { case ExcelExtType.xlsx: workbook = new XSSFWorkbook(stream); break; default: workbook = new HSSFWorkbook(stream); break; } ISheet sheet = null; //获取工作表 默认取第一张 if (string.IsNullOrWhiteSpace(sheetName)) sheet = workbook.GetSheetAt(0); else sheet = workbook.GetSheet(sheetName); if (sheet == null) return null; IEnumerator rows = sheet.GetRowEnumerator(); #region 获取表头 IRow headerRow = sheet.GetRow(0); int cellCount = headerRow.LastCellNum; for (int j = 0; j &lt; cellCount; j++) { ICell cell = headerRow.GetCell(j); if (cell != null) { dt.Columns.Add(cell.ToString()); } else { dt.Columns.Add(&quot;&quot;); } } #endregion #region 获取内容 for (int i = (sheet.FirstRowNum + 1); i &lt;= sheet.LastRowNum; i++) { IRow row = sheet.GetRow(i); DataRow dataRow = dt.NewRow(); for (int j = row.FirstCellNum; j &lt; cellCount; j++) { if (row.GetCell(j) != null) { //判断单元格是否为日期格式 if (row.GetCell(j).CellType == NPOI.SS.UserModel.CellType.Numeric &amp;&amp; HSSFDateUtil.IsCellDateFormatted(row.GetCell(j))) { if (row.GetCell(j).DateCellValue.Year &gt;=1970) { dataRow[j] = row.GetCell(j).DateCellValue.ToString(); } else { dataRow[j] = row.GetCell(j).ToString(); } } else { dataRow[j] = row.GetCell(j).ToString(); } } } dt.Rows.Add(dataRow); } #endregion } catch (Exception ex) { dt=null; } finally { //if (stream != null) //{ // stream.Close(); // stream.Dispose(); //} } return dt; } 2. 文件上载导入/// &lt;summary&gt; /// 上传Excel导入 /// &lt;/summary&gt; /// &lt;param name=&quot;file&quot;&gt;上载文件对象&lt;/param&gt; /// &lt;param name=&quot;errorMsg&quot;&gt;错误信息&lt;/param&gt; /// &lt;param name=&quot;sheetName&quot;&gt;表名，默认取第一张&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable Import(System.Web.HttpPostedFileBase file, ref string errorMsg, string sheetName = &quot;&quot;) { if (file == null || file.InputStream == null || file.InputStream.Length == 0) { errorMsg = &quot;请选择要导入的Excel文件&quot;; return null; } var excelType = GetExcelFileType(file.FileName); if (excelType == null) { errorMsg = &quot;请选择正确的Excel文件&quot;; return null; } using (var stream = new MemoryStream()) { file.InputStream.Position = 0; file.InputStream.CopyTo(stream); var dt = ImportExcel(stream, excelType.Value, sheetName); if (dt == null) errorMsg = &quot;导入失败,请选择正确的Excel文件&quot;; return dt; } } 3. 本地路径读取导入/// &lt;summary&gt; /// 根据文件路径导入Excel /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;errorMsg&quot;&gt;错误信息&lt;/param&gt; /// &lt;param name=&quot;sheetName&quot;&gt;表名，默认取第一张&lt;/param&gt; /// &lt;returns&gt;可能为null的DataTable&lt;/returns&gt; public static DataTable Import(string filePath, ref string errorMsg, string sheetName = &quot;&quot;) { var excelType = GetExcelFileType(filePath); if (GetExcelFileType(filePath) == null) { errorMsg = &quot;请选择正确的Excel文件&quot;; return null; } if (!File.Exists(filePath)) { errorMsg = &quot;没有找到要导入的Excel文件&quot;; return null; } DataTable dt; using (var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) { dt = ImportExcel(stream, excelType.Value, sheetName); } if (dt == null) errorMsg = &quot;导入失败,请选择正确的Excel文件&quot;; return dt; } 4.完整demo附赠一个winform导入Excel的Demo。https://github.com/yimogit/NopiExcelDemo"},{"title":"MSMQ队列学习记录","permalink":"https://yimogit.github.io/2017/04/21/MSMQ队列学习记录/","text":"微软消息队列-MicroSoft Message Queue(MSMQ) 使用感受：简单。 一、windows安装MSMQ服务控制面板-&gt;控制面板-&gt;所有控制面板项-&gt;程序和功能-&gt;选中安装 然后可在计算机管理–&gt;服务和应用程序-&gt;消息队列查看队列信息 二、C#中使用MSMQ使用MessageQueue类操作MSMQ，其在System.Messaging命名空间下，需要添加引用 定义的接口1234567891011121314151617public interface IMessageSender&lt;T&gt; : IDisposable&#123; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;消息对象&lt;/param&gt; void SendMessage(T message); void SendMessages(List&lt;T&gt; message); /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;消息对象&lt;/param&gt; /// &lt;param name=&quot;label&quot;&gt;消息标签&lt;/param&gt; void SendMessage(T message, string label);&#125; 接口实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/// &lt;summary&gt;/// 消息队列对象，由MQueueFactory创建指定路径的队列对象，可发送或批量接收消息。/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;消息队列存储的消息对象类型&lt;/typeparam&gt;public sealed class MQueue&lt;T&gt; : IDisposable, IMessageSender&lt;T&gt;, IMessageReceiver&lt;T&gt;&#123; public MQueue(MessageQueue mq, string user = &quot;Everyone&quot;) &#123; InnerQueue = mq; InnerQueue.Formatter = new XmlMessageFormatter(new[] &#123; typeof(T) &#125;); InnerQueue.SetPermissions(user ?? &quot;Everyone&quot;, MessageQueueAccessRights.GenericRead | MessageQueueAccessRights.DeleteMessage | MessageQueueAccessRights.DeleteQueue | MessageQueueAccessRights.DeleteJournalMessage); &#125; #region IMessageSender /// &lt;summary&gt; /// 内部消息队列对象 /// &lt;/summary&gt; private MessageQueue InnerQueue &#123; get; set; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;消息对象&lt;/param&gt; public void SendMessage(T message) &#123; InnerQueue.Send(message); &#125; public void SendMessages(List&lt;T&gt; message) &#123; foreach (var item in message) &#123; InnerQueue.Send(item); &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;消息对象&lt;/param&gt; /// &lt;param name=&quot;label&quot;&gt;消息标签&lt;/param&gt; public void SendMessage(T message, string label) &#123; try &#123; InnerQueue.Send(message, label); &#125; catch (Exception ex) &#123; var path = InnerQueue.Path; InnerQueue = new MessageQueue(path); &#125; &#125; #endregion #region IMessageReceiver /// &lt;summary&gt; /// 获取队列中所有消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;消息类型&lt;/typeparam&gt; /// &lt;param name=&quot;exTarget&quot;&gt;异常时触发&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;T&gt; GetAllMessages&lt;T&gt;(MQExceptionTarget exTarget = null) &#123; return GetMessagesByNum&lt;T&gt;(null, exTarget); &#125; /// &lt;summary&gt; /// 获取队列中指定数量消息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;消息类型&lt;/typeparam&gt; /// &lt;param name=&quot;num&quot;&gt;一次最多取num条数据，默认取所有数据&lt;/param&gt; /// &lt;param name=&quot;exTarget&quot;&gt;异常委托&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;T&gt; GetMessagesByNum&lt;T&gt;(int? num = null, MQExceptionTarget exTarget = null) &#123; var list = new List&lt;T&gt;(); if (num.HasValue &amp;&amp; num &lt;= 0) &#123; return list; &#125; MessageEnumerator enumerator = InnerQueue.GetMessageEnumerator2(); while (enumerator.MoveNext()) &#123; Message msg = enumerator.RemoveCurrent(); enumerator.Reset(); if (msg != null) &#123; try &#123; list.Add((T)msg.Body); if (num.HasValue &amp;&amp; list.Count &gt;= num) &#123; break; &#125; &#125; catch (Exception ex) &#123; if (exTarget != null) exTarget(ex); &#125; &#125; &#125; return list; &#125; #endregion public void Dispose() &#123; if (InnerQueue != null) &#123; InnerQueue.Dispose(); &#125; &#125;&#125; 建立队列工厂1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// &lt;summary&gt;/// 消息队列工厂，通过指定路径创建或获取相应队列对象/// &lt;/summary&gt;public class MQueueFactory&#123; /// &lt;summary&gt; /// 默认队列路径，在未指定路径的情况下，将创建并返回该路径的消息队列对象 /// &lt;/summary&gt; private const string DefaultPath = @&quot;.\\private$\\myQueue&quot;; /// &lt;summary&gt; /// 创建默认路径的消息队列对象 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;消息队列存储的消息对象类型&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public static MQueue&lt;T&gt; Create&lt;T&gt;() &#123; return Create&lt;T&gt;(DefaultPath); &#125; /// &lt;summary&gt; /// 创建指定路径的消息队列路径 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;消息队列存储的消息对象类型&lt;/typeparam&gt; /// &lt;param name=&quot;connStr&quot;&gt;指定的消息队列链接字符串 def:&quot;.\\private$\\myQueue&quot;&lt;/param&gt; /// &lt;param name=&quot;autoCreate&quot;&gt;不存在则创建队列 远程地址不能创建&lt;/param&gt; /// &lt;param name=&quot;user&quot;&gt;获得队列额外权限的个人、组或计算机&lt;/param&gt; /// &lt;param name=&quot;cacheKey&quot;&gt;web中Cache键值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static MQueue&lt;T&gt; Create&lt;T&gt;(string connStr=@&quot;.\\private$\\myQueue&quot;, bool autoCreate = false, string user = &quot;Everyone&quot;, string cacheKey = &quot;MQCache&quot;) &#123; string path = connStr ?? DefaultPath; HttpContext httpContext = HttpContext.Current; if (autoCreate &amp;&amp; !MessageQueue.Exists(path)) &#123; MessageQueue.Create(path); &#125; var mq = new MessageQueue(path); if (httpContext != null) &#123; string key = &quot;MQueue&quot; + typeof(T).Name + cacheKey; if ((httpContext.Cache[key] == null)) &#123; httpContext.Cache[key] = new MQueue&lt;T&gt;(mq); &#125; return httpContext.Cache[key] as MQueue&lt;T&gt;; &#125; return new MQueue&lt;T&gt;(mq,user); &#125;&#125; 写入队列MQueueFactory.Create&lt;string&gt;(@&quot;.\\private$\\myQueue&quot;, autoCreate: true).SendMessage(&quot;我是写入的数据~~~&quot;); 获取消息MQueueFactory.Create&lt;string&gt;(@&quot;.\\private$\\myQueue&quot;).GetAllMessages&lt;string&gt;();"},{"title":"weexpack打包weex项目运行及打包记录","permalink":"https://yimogit.github.io/2017/03/01/weexpack打包weex项目运行及打包记录/","text":"构建weex项目 安装weex-toolkit cnpm install -g weex-toolkit 初始化一个项目只需新建文件夹并在目录下执行 weex init 即可 安装依赖：cnpm install 编译项目：npm run dev 启动服务器：npm run serve //可以修改package.json的端口号来改变监听端口 可以执行的命令一览 使用weexpack打包weex项目 各种百度 ‘weex打包’ ‘如何打包weex apk’ ‘weex 发布 apk’ 未果最后在这里看到了这玩意T_T weexpack 介绍 更多详情见Githubweexpack 是 weex 新一代的工程开发套件，是基于weex快速搭建应用原型的利器。它能够帮助开发者通过命令行创建weex工程，添加相应平台的weex app模版，并基于模版从本地、GitHub 或者 weex 应用市场安装插件，快速打包 weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建weex插件模版并发布插件到weex应用市场。 开始我的安装 安装Android需要的环境：android环境折腾可参考windows下react-native环境搭建 安装weexpack：项目地址 cnpm install -g weexpack 初始化一个weexpack程序： weexpack init dsb-weexpack 还原依赖： cnpm install 如果没有安装android SDK的好需要去安装sdk，安装好了就添加平台到项目：weexpack platform add android 修改gradle-wrapper.properties文件gradle下载地址distributionUrl值为：distributionUrl=file:///F:/gradle-2.14.1-all.zip 打包编译： weexpack build android 苦等ing…… 两天过去了，于3月1日清晨成功下载完毕，且没有挂vpn~生成文件如图所示 在夜神模拟器运行：首先使用adb连接到夜神模拟器adb connect 127.0.0.1:62001,再执行weexpack run android即可在模拟器中运行 参考 https://github.com/weexteam/weex-packhttps://github.com/vczero/weex-learninghttps://github.com/apache/incubator-weex"},{"title":"使用Python多渠道打包apk","permalink":"https://yimogit.github.io/2017/02/18/使用Python多渠道打包apk/","text":"往apk包中追加到一个空文件到META-INF目录以标识渠道，Android中获取此文件即可获得App的下载渠道 首先在info文件夹新建一个qdb.txt的空文本文件 新建channel.txt存放渠道来源 运行Python代码即可将目录下的apk生成多渠道文件包 Python代码如下：#!/usr/bin/python # coding=utf-8 import zipfile import shutil import os # 空文件 便于写入此空文件到apk包中作为channel文件 src_empty_file = &apos;info/qdb.txt&apos; # 创建一个空文件（不存在则创建） f = open(src_empty_file, &apos;w&apos;) f.close() # 获取当前目录中所有的apk源包 src_apks = [] # python3 : os.listdir()即可，这里使用兼容Python2的os.listdir(&apos;.&apos;) for file in os.listdir(&apos;.&apos;): if os.path.isfile(file): extension = os.path.splitext(file)[1][1:] if extension in &apos;apk&apos;: src_apks.append(file) # 获取渠道列表 channel_file = &apos;info/channel.txt&apos; f = open(channel_file) lines = f.readlines() f.close() for src_apk in src_apks: # file name (with extension) src_apk_file_name = os.path.basename(src_apk) # 分割文件名与后缀 temp_list = os.path.splitext(src_apk_file_name) # name without extension src_apk_name = temp_list[0] # 后缀名，包含. 例如: &quot;.apk &quot; src_apk_extension = temp_list[1] # 创建生成目录,与文件名相关 output_dir = &apos;output_&apos; + src_apk_name + &apos;/&apos; # 目录不存在则创建 if not os.path.exists(output_dir): os.mkdir(output_dir) # 遍历渠道号并创建对应渠道号的apk文件 for line in lines: # 获取当前渠道号，因为从渠道文件中获得带有\\n,所有strip一下 target_channel = line.strip() # 拼接对应渠道号的apk target_apk = output_dir + src_apk_name + &quot;-&quot; + target_channel + src_apk_extension # 拷贝建立新apk shutil.copy(src_apk, target_apk) # zip获取新建立的apk文件 zipped = zipfile.ZipFile(target_apk, &apos;a&apos;, zipfile.ZIP_DEFLATED) # 初始化渠道信息 empty_channel_file = &quot;META-INF/qdb_{channel}&quot;.format(channel = target_channel) # 写入渠道信息 zipped.write(src_empty_file, empty_channel_file) # 关闭zip流 zipped.close() Android中读取文件取得渠道ID/** 获取渠道ID **/ public String getChannelId() { Context context = cordova.getActivity().getApplicationContext(); //从apk包中获取 ApplicationInfo appinfo = context.getApplicationInfo(); String sourceDir = appinfo.sourceDir; //默认放在meta-inf/里， 所以需要再拼接一下 String key = &quot;META-INF/qdbchannel&quot;; String ret = &quot;&quot;; ZipFile zipfile = null; try { zipfile = new ZipFile(sourceDir); Enumeration&lt;?&gt; entries = zipfile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = ((ZipEntry) entries.nextElement()); String entryName = entry.getName(); if (entryName.startsWith(key)) { ret = entryName; break; } } } catch (IOException e) { e.printStackTrace(); } finally { if (zipfile != null) { try { zipfile.close(); } catch (IOException e) { e.printStackTrace(); } } } String[] split = ret.split(&quot;_&quot;); String channel = &quot;&quot;; if (split != null &amp;&amp; split.length &gt;= 2) { channel = ret.substring(split[0].length() + 1); } return channel; } 附上查看apk内文件方法 新建一个压缩包 打开压缩包 在压缩包内回退双击进入apk文件即可"},{"title":"react学习记录","permalink":"https://yimogit.github.io/2017/02/12/react学习记录/","text":"react学习记录2017.01.08 在iOS上使用http链接的图片地址可能不会显示，参见这篇说明修改。 需要的组件都要在顶部引用。 不能直接在组件外面写样式，需要显示传递，样式名按骆驼命名法书写顺序声明和使用style属性，以借鉴CSS中的“层叠”做法（即后声明的属性会覆盖先声明的同名属性） Flexbox布局的说明 http://reactnative.cn/docs/0.40/layout-props.html react-native 项目初始化 搭建java，android，node环境 http://www.cnblogs.com/morang/p/react-native-java-build.html 全局安装脚手架 npm install react-native-cli -g 使用react-native-cli初始化项目 react-native init 项目名称 修改android/gradle/wrapper/gradle-wrapper.properties文件的distributionUrl值为本地路径(墙) distributionUrl=file:///F:/CodingRepos/reactDemo/gradle-2.4-all.zip 绑定模拟器或真机 可以使用adb devices查看连接的设备 5.1 使用夜神模拟器安装调试app 5.2 使用adb命令链接设备到模拟器：adb connect 127.0.0.1:62001 端口号可使用 安装目录nox/bin/下的nox_adb devices查看或者查看进程PID 多个真机连接可用此connect Ip:port的方式连接到指定设备 5.3 若使用真机调试需要打开USB调试并允许通过USB安装应用 开始构建 react-native run-android 构建时会启动8081端口为服务端来在保存代码后进行更新 点击模拟器的摇一摇（Ctrl+0）选择Dev Setting-&gt;Debug Server host &amp; port for device-&gt; 电脑IP:8081 返回到桌面摇一摇~Reload~Over。"},{"title":"从零开始在win10系统搭建react-native开发环境","permalink":"https://yimogit.github.io/2017/01/07/从零开始在win10系统搭建react-native开发环境/","text":"win10 react-native环境搭建 首先不得不先吐槽一下自己，一个坑总是踩很多次，且乐此不疲。咋办? 写博客记录记录呗。 零、记录的点 Java环境的下载与配置 Android环境的下载与配置 Node环境的下载与配置 创建第一个react-native应用 最终能够达到的目的：在手机上能够运行第一个React-Native应用~ 以备后用，已将安装包上传到了网盘 密码：bqbc 一、Java环境的下载与配置记录下Java里面的三个术语理解 JDK是什么？ 答曰：JDK乃【Java开发工具包】 (Java Development Kit ) 的缩写,是一种用于构建在 Java 平台上发布的应用程序、applet 和组件的开发环境 JRE是什么？ 答曰：JRE乃【Java运行环境】(Java Runtime Environment)的缩写,其包含JVM标准实现及Java核心类库 JVM是什么？ 答曰：JVM是【Java虚拟机】(Java Virtual Machine)的缩写 下载安装配置JDK 到官网 或者android-studio下载JDK 安装JDK，我安装到的D:\\Software\\JavaJdk 必须得配置环境变量滴 ①java_home:D:\\Software\\JavaJdk ②classpath(.;开头):.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar ③追加path变量的值:;%java_home%\\bin 二、Android环境的下载与配置下载Android SDK 到android-studio下载SDK。运行installer_r24.4.1-windows.exe安装、或zip解压出来的SDK Manager.exe 然后我安装了以下这些包(我的react-native版本是0.40.0) SDKManager使用说明： 被镜像坑了，所以不推荐镜像，直接修改hosts文件就成—&gt;去找最新的hosts镜像地址—&gt;去找最新的镜像地址 镜像使用说明 使用镜像安装不了23.0.1的同学趁早换hosts的方式或者挂vpn。 科学上网还是得备个vpn呐~~~ SDK包下好了，接下来就配置系统环境变量吧 ①ANDROID_HOME:D:\\Software\\JavaAndroidSdk②追加path变量的值:%ANDROID_HOME%\\platforms\\;%ANDROID_HOME%\\platform-tools\\;%ANDROID_HOME%\\tools\\;%ANDROID_HOME%;我的Path图 测试Java环境，Android环境 失败自行回退检查~~ 三、安装node.jsnode官网历史版本修改下载链接的值就能下载历史版本了如：我使用的是版本是V6.2.0然后就是node的一些设置了npm config set prefix &quot;D:\\Program Files\\nodejs\\node_global&quot; //设置全局包目录,全局安装的工具等会放在此目录下，故windows下需要设置环境变量npm config set cache &quot;D:\\Program Files\\nodejs\\node_cache&quot; //设置缓存目录npm config set registry https://registry.npm.taobao.org&quot; //设置淘宝镜像 之前有安装过node，卸载旧版重新安装到之前的目录就==升级了npm升级命令npm update 四、创建第一个在手机上运行的react-native应用 启动CMD定位到开发目录：例F:\\ReactDemo 全局安装npm install -g react-native-cli 初始化一个项目：react-native init yimoapp cd yimoapp 运行packager：react-native start 如果你碰到了ERROR Watcher took too long to load的报错，请尝试将这个文件中的MAX_WAIT_TIME值改得更大一些 (文件在node_modules/react-native/目录下)。成功运行这时候可以用浏览器访问http//localhost:8081/index.android.bundle?platform=android查看服务端是否已成功启动 真机运行,使用usb连接手机，开启USB调试权限 查看连接的设备：adb devices react-native run-android构建工程并自动安装到手机 不要慌，先做点准备工作。手动下载gradle-2.4-all.zip到本地修改 F:\\ReactDemo\\yimoapp\\android\\gradle\\wrapper\\gradle-wrapper.properties文件的distributionUrl配置为[本地的gradle-2.4-all.zip路径]以使其可离线下载 包安装得差不多的时候会提示你安装应用 可能会有一个这样的错误，奇怪的是第一次安装有,这一次安装就没有遇到了。 将android/build.gradle文件中的 classpath ‘com.android.tools.build:gradle:1.3.1’ 改为 classpath ‘com.android.tools.build:gradle:1.2.3’ 。猜测是插件包不兼容导致。 解决白屏问题找到并开启应用的悬浮窗权限,以mui8.1为例，设置-&gt;授权管理-&gt;应用权限管理-&gt;yimoapp-&gt;勾选显示浮窗权限然后再次打开yimoapp。我去。这次来个大红色的错误了 咋办。摇一摇说不定有奇迹 在回退刷新前。我去改了改index.android.js，好了回到页面摇一摇然后刷新 总结与收获总结是很有必要的。有很多问题是在Java和Android环境没有弄好的情况下会出现的。参考文章： http://www.tuicool.com/articles/26byiuZ 这里面的错我也都遇到过~~ http://www.cnblogs.com/suxun/p/5220564.html 有配置模拟器的 一天就这样结束，一天就这样开始。"},{"title":"过去式的blogsv3","permalink":"https://yimogit.github.io/2017/01/01/过去式的blogsv3/","text":"BlogV3–此为过去式~截图留恋 图片再也找不回来了~BlogV4已上线：hexo强力驱动 https://coding.net/u/yimocoding/p/yimocoding/git 博客满血复活了，啦啦啦 不知不觉天就亮了，2017年的第一步也随着朝霞的升起而迈出。http://www.yimo.link/ 我的博客又活过来了;第一版是在2015,第二版是在2016，第三版即这一版在今天2017年1月1日;每一个版本都收获了许多，成长了许多，让自己知道幸苦是没有白费的;从第一版的后台使用angularjs+webapi的快速开发，到第二版的asp.net mvc的正确使用姿势，再到第三版的node-express-jshtml。踩了无数的坑，熬了无数的夜，做出东西了，那无与伦比的成就感。哈哈哈哈哈哈 只有不断的尝试，才会有所获，有所得。 回首2016，我还做了这些玩意一、 尝试着搭建了一个asp.net mvc的框架：YimoFramework源码二、 C#写的一个自动签到的服务：AutomaticSignService源码三、 node写的一个抓数据的程序：YFKDataGrab源码四、 用vue2.0+mui3.3写了一个导航的App：vue-mui-app源码 http://app.yimo.link/五、 用vue2.0+layui封装了一些组件，后面做博客的后台管理：vue-layui源码 http://vue-layui.yimo.link/#/admin六、node-express+jshtml写的博客站点：yimocoding源码 http://www.yimo.link 如图图所示，2016结束了，2017，迎接新的改变吧。 等等，还没完呢。踩的坑还没有记录呢 问：jshtml文件没有语法高亮，看着好难受怎么办 答： vscode是可以配置文件管理的,文件-》首选项-》用户设置-》设置files.associations即可 问：写node的使用，node_modules如何不让他提交到git，不包含到工作区？ 答: 1问配置.gitignore文件，添加一行node_modules/即可;vscode可以设置files.exclude排除文件/夹 问：nginx到底要怎么配置反向代理,又如何再windows服务器上使用nginx后不影响存在的iis站点（公用80） 答：访问www.yimo.link会经由nginx转发到代理地址上，如果服务器使用iis就将iis中的站点重新配置其他端口，然后一个站点配置一个server即可 server { listen 80; server_name www.yimo.link;//解析的域名 location / { proxy_pass http://127.0.0.1:2333; //代理的地址/域名+端口的形式也可以 } over，发布，睡觉。"},{"title":"asp.net mvc项目自定义区域","permalink":"https://yimogit.github.io/2016/12/30/asp.net-mvc项目自定义区域/","text":"前言 直接上干货就是，就不废话了。使用场景：分离模块，多站点等~~ 一、分离模块 自定义视图引擎，设置视图路径格式项目结构图 1.Code: 在Global.asax Application_Start方法中添加自定义的视图引擎using System.Collections.Generic; using System.Web.Mvc; namespace MvcProjectMain.AreasViewEngine { /// &lt;summary&gt; /// 自定义视图引擎 /// &lt;/summary&gt; /// &lt;remarks&gt; /// ViewEngines.Engines.Add(new MvcProjectMain.AreasViewEngine.ThemableRazorViewEngine()); /// &lt;/remarks&gt; public class ThemableRazorViewEngine : VirtualPathProviderViewEngine { //所有区域分离到Modules文件夹,{2}为区域名 public ThemableRazorViewEngine() { ViewEngines.Engines.Clear(); AreaViewLocationFormats = new[] { &quot;~/Modules/{2}/Views/{1}/{0}.cshtml&quot;, &quot;~/Modules/{2}/Views/Shared/{0}.cshtml&quot;, }; AreaMasterLocationFormats = new[] { &quot;~/Modules/{2}/Views/{1}/{0}.cshtml&quot;, &quot;~/Modules/{2}/Views/Shared/{0}.cshtml&quot;, }; AreaPartialViewLocationFormats = new[] { &quot;~/Modules/{2}/Views/{1}/{0}.cshtml&quot;, &quot;~/Modules/{2}/Views/Shared/{0}.cshtml&quot;, }; ViewLocationFormats = new[] { &quot;~/Views/{1}/{0}.cshtml&quot;, &quot;~/Views/Shared/{0}.cshtml&quot;, }; MasterLocationFormats = new[] { &quot;~/Views/{1}/{0}.cshtml&quot;, &quot;~/Views/Shared/{0}.cshtml&quot;, }; PartialViewLocationFormats = new[] { &quot;~/Views/{1}/{0}.cshtml&quot;, &quot;~/Views/Shared/{0}.cshtml&quot;, }; FileExtensions = new[] { &quot;cshtml&quot; }; } protected override IView CreatePartialView(ControllerContext controllerContext, string partialPath) { string layoutPath = null; var runViewStartPages = false; IEnumerable&lt;string&gt; fileExtensions = base.FileExtensions; return new RazorView(controllerContext, partialPath, layoutPath, runViewStartPages, fileExtensions); } protected override IView CreateView(ControllerContext controllerContext, string viewPath, string masterPath) { string layoutPath = masterPath; var runViewStartPages = true; IEnumerable&lt;string&gt; fileExtensions = base.FileExtensions; return new RazorView(controllerContext, viewPath, layoutPath, runViewStartPages, fileExtensions); } } } 2.Code:在Global.asax中添加注册区域–&gt;AreaRegistration.RegisterAllAreas(); public class ThemesAreaRegistration : AreaRegistration { public override string AreaName { get { return &quot;MvcProjectThemes&quot;; } } public override void RegisterArea(AreaRegistrationContext context) { context.MapRoute( &quot;MvcProjectThemes&quot;, &quot;MvcProjectThemes/{controller}/{action}/{id}&quot;, new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional, }, namespaces: new string[] { &quot;MvcProjectThemes.Controllers&quot; } ); } } 3.Code:注册主项目MvcProjectMain的路由 RouteConfig.RegisterRoutes(RouteTable.Routes); namespace MvcProjectMain { public class RouteConfig { public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(&quot;{resource}.axd/{*pathInfo}&quot;); routes.MapRoute( name: &quot;Default&quot;, url: &quot;{controller}/{action}/{id}&quot;, defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional }, namespaces: new string[] { &quot;MvcProjectMain.Controllers&quot; } ); } } } 最后主要代码就是步骤1中的ThemableRazorViewEngine.cs类。自定义查找路径，其他的都是MVC的基础知识了,不懂自行查阅资料"},{"title":"开心一刻","permalink":"https://yimogit.github.io/2010/07/02/jokes/开心一刻/","text":"公园长凳上，她小鸟依人般靠在他的肩膀，一边摩挲着他的衣角，一边喃喃地说：“亲爱的，虽然我们认识没多久，但我觉得每天都过得好充实，一起经历了那么多事情，感觉我们像认识了好久好久一样呢。”他轻轻搂了搂她，深情地答道：“是啊，也许这就是人们常说的度日如年吧。” “知道为什么我们拥抱的时候能够强烈感受到彼此的心跳？”“是因为我们爱的深，心相连？”“不，是因为你平胸。” 三个年轻人聊天。A：今天天气真热，应该戴个帽子。B：好主意啊，最好带个绿帽子。C：确实是好主意，不光身上凉，心里也拔凉拔凉的。 现在的人真是爱管闲事！我跟我女朋友在电话里吵架关他什么事？他又不认识我女朋友。更可恶的他还叫来了保安！真讨厌，以后再也不来这家电影院了。 和同班一个MM玩足球，我说：“我守门可厉害，外号铜墙！！”MM说：“切~~~ 我外号钢门！！我让你随便射，你也射不进来！！”说完我爆笑，MM一路猛追打我。。。"},{"title":"程序员漫画-010101","permalink":"https://yimogit.github.io/2010/07/02/pics/美图鉴赏/","text":""}]}